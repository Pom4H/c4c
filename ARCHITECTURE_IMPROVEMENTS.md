# –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —É—Å–∏–ª–µ–Ω–∏—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã tsdev

## üìä –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

### –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã
‚úÖ **Contracts-first –ø–æ–¥—Ö–æ–¥** - –µ–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã  
‚úÖ **Transport-agnostic** - –æ–¥–∏–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–æ–≤  
‚úÖ **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è** - zero boilerplate —á–µ—Ä–µ–∑ collectRegistry()  
‚úÖ **OpenTelemetry –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è** - observability –≤—Å—Ç—Ä–æ–µ–Ω–∞ –≤ —è–¥—Ä–æ  
‚úÖ **Composable policies** - —Ä–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü–∏–∏  
‚úÖ **Workflow —Å–∏—Å—Ç–µ–º–∞** - –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –≥—Ä–∞—Ñ—ã –∏–∑ –ø—Ä–æ—Ü–µ–¥—É—Ä  

### –û–±–ª–∞—Å—Ç–∏ –¥–ª—è —É—Å–∏–ª–µ–Ω–∏—è
‚ùå **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ** - –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–µ—Å—Ç–æ–≤  
‚ùå **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞  
‚ùå **–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –±–∞–∑–æ–≤–∞—è, —Ç—Ä–µ–±—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏–∏  
‚ùå **–í–∞–ª–∏–¥–∞—Ü–∏—è** - —Ç–æ–ª—å–∫–æ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ö, –Ω–µ—Ç runtime –ø—Ä–æ–≤–µ—Ä–æ–∫  
‚ùå **–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ** - –Ω–µ—Ç –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤ –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º  
‚ùå **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è** - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –µ—Å—Ç—å, –Ω–æ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø—Ä–∏–º–µ—Ä–æ–≤  
‚ùå **DX (Developer Experience)** - –Ω—É–∂–Ω—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞  

---

## üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

### 1. –¢–µ—Å—Ç–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (HIGH PRIORITY)

#### –ü—Ä–æ–±–ª–µ–º–∞
- –ù–µ—Ç unit/integration —Ç–µ—Å—Ç–æ–≤
- –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç test framework setup
- –ù–µ—Ç –ø—Ä–∏–º–µ—Ä–æ–≤ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

#### –†–µ—à–µ–Ω–∏–µ

**1.1. –°–æ–∑–¥–∞—Ç—å –ø–∞–∫–µ—Ç `@tsdev/testing`**

```typescript
// packages/testing/src/index.ts
import type { Procedure, Registry, ExecutionContext } from '@tsdev/core';

/**
 * Test utilities for tsdev
 */

// Mock registry builder
export function createMockRegistry(): Registry {
  return new Map();
}

// Test execution context builder
export function createTestContext(
  overrides: Partial<ExecutionContext> = {}
): ExecutionContext {
  return {
    requestId: 'test-req-123',
    timestamp: new Date('2024-01-01'),
    metadata: {},
    ...overrides,
  };
}

// Procedure test helper
export async function testProcedure<TInput, TOutput>(
  procedure: Procedure<TInput, TOutput>,
  input: TInput,
  context?: Partial<ExecutionContext>
) {
  const ctx = createTestContext(context);
  return procedure.handler(input, ctx);
}

// Contract validation tester
export function validateContract(
  procedure: Procedure,
  testCases: Array<{ input: unknown; expectedValid: boolean }>
) {
  const results = testCases.map(({ input, expectedValid }) => {
    try {
      procedure.contract.input.parse(input);
      return { input, valid: true, matches: expectedValid };
    } catch {
      return { input, valid: false, matches: !expectedValid };
    }
  });
  
  return {
    passed: results.every(r => r.matches),
    results,
  };
}

// HTTP adapter testing helper
export class TestHttpClient {
  constructor(private baseUrl: string) {}
  
  async callProcedure(name: string, input: unknown) {
    const response = await fetch(`${this.baseUrl}/rpc/${name}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input),
    });
    return response.json();
  }
}

// Workflow testing utilities
export function createMockWorkflow(
  overrides: Partial<WorkflowDefinition> = {}
): WorkflowDefinition {
  return {
    id: 'test-workflow',
    name: 'Test Workflow',
    version: '1.0.0',
    startNode: 'start',
    nodes: [],
    ...overrides,
  };
}
```

**1.2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å vitest –¥–ª—è –≤—Å–µ—Ö –ø–∞–∫–µ—Ç–æ–≤**

```typescript
// vitest.config.ts (root)
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['packages/*/src/**/*.ts'],
      exclude: ['**/*.test.ts', '**/*.spec.ts', '**/index.ts'],
    },
  },
});
```

**1.3. –ü—Ä–∏–º–µ—Ä—ã —Ç–µ—Å—Ç–æ–≤**

```typescript
// packages/core/src/executor.test.ts
import { describe, it, expect, vi } from 'vitest';
import { executeProcedure, createExecutionContext } from './executor.js';
import { z } from 'zod';

describe('executeProcedure', () => {
  it('should validate input and output', async () => {
    const procedure = {
      contract: {
        name: 'test.add',
        input: z.object({ a: z.number(), b: z.number() }),
        output: z.object({ result: z.number() }),
      },
      handler: async (input: { a: number; b: number }) => ({
        result: input.a + input.b,
      }),
    };
    
    const context = createExecutionContext();
    const result = await executeProcedure(procedure, { a: 2, b: 3 }, context);
    
    expect(result).toEqual({ result: 5 });
  });
  
  it('should throw on invalid input', async () => {
    const procedure = {
      contract: {
        name: 'test.add',
        input: z.object({ a: z.number(), b: z.number() }),
        output: z.object({ result: z.number() }),
      },
      handler: async (input: { a: number; b: number }) => ({
        result: input.a + input.b,
      }),
    };
    
    const context = createExecutionContext();
    
    await expect(
      executeProcedure(procedure, { a: 'invalid' }, context)
    ).rejects.toThrow();
  });
});
```

---

### 2. –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ (HIGH PRIORITY)

#### –ü—Ä–æ–±–ª–µ–º–∞
- –ù–µ—Ç –µ–¥–∏–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –æ—à–∏–±–æ–∫
- –û—à–∏–±–∫–∏ –Ω–µ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
- –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç error codes
- –ù–µ—Ç recovery –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤

#### –†–µ—à–µ–Ω–∏–µ

**2.1. –°–æ–∑–¥–∞—Ç—å —Å–∏—Å—Ç–µ–º—É typed errors**

```typescript
// packages/core/src/errors.ts

/**
 * Base error class for tsdev framework
 */
export class TsdevError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
  
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      statusCode: this.statusCode,
      details: this.details,
    };
  }
}

// Domain-specific errors
export class ValidationError extends TsdevError {
  constructor(message: string, details?: Record<string, unknown>) {
    super(message, 'VALIDATION_ERROR', 400, details);
  }
}

export class ProcedureNotFoundError extends TsdevError {
  constructor(procedureName: string) {
    super(
      `Procedure '${procedureName}' not found`,
      'PROCEDURE_NOT_FOUND',
      404,
      { procedureName }
    );
  }
}

export class ExecutionError extends TsdevError {
  constructor(message: string, cause?: Error) {
    super(message, 'EXECUTION_ERROR', 500, {
      cause: cause?.message,
      stack: cause?.stack,
    });
  }
}

export class RateLimitError extends TsdevError {
  constructor(retryAfter?: number) {
    super(
      'Rate limit exceeded',
      'RATE_LIMIT_EXCEEDED',
      429,
      { retryAfter }
    );
  }
}

export class AuthenticationError extends TsdevError {
  constructor(message = 'Authentication required') {
    super(message, 'AUTHENTICATION_ERROR', 401);
  }
}

export class AuthorizationError extends TsdevError {
  constructor(message = 'Insufficient permissions') {
    super(message, 'AUTHORIZATION_ERROR', 403);
  }
}

export class TimeoutError extends TsdevError {
  constructor(timeoutMs: number) {
    super(
      `Operation timed out after ${timeoutMs}ms`,
      'TIMEOUT_ERROR',
      408,
      { timeoutMs }
    );
  }
}

// Error handler utility
export function handleError(error: unknown): TsdevError {
  if (error instanceof TsdevError) {
    return error;
  }
  
  if (error instanceof Error) {
    return new ExecutionError(error.message, error);
  }
  
  return new ExecutionError(String(error));
}
```

**2.2. –û–±–Ω–æ–≤–∏—Ç—å executor —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫**

```typescript
// packages/core/src/executor.ts
import { ValidationError, ExecutionError, handleError } from './errors.js';

export async function executeProcedure<TInput, TOutput>(
  procedure: Procedure<TInput, TOutput>,
  input: unknown,
  context: ExecutionContext
): Promise<TOutput> {
  try {
    // Validate input
    const validatedInput = procedure.contract.input.parse(input);
    
    // Execute handler
    const result = await procedure.handler(validatedInput, context);
    
    // Validate output
    const validatedOutput = procedure.contract.output.parse(result);
    
    return validatedOutput;
  } catch (error) {
    // Handle Zod validation errors
    if (error?.name === 'ZodError') {
      throw new ValidationError('Input validation failed', {
        issues: error.issues,
      });
    }
    
    // Re-throw known errors
    throw handleError(error);
  }
}
```

**2.3. Error recovery policy**

```typescript
// packages/policies/src/withErrorRecovery.ts
import type { Policy, Handler } from '@tsdev/core';
import { TsdevError } from '@tsdev/core/errors';

export interface ErrorRecoveryOptions {
  fallback?: (error: TsdevError, input: unknown) => unknown;
  logErrors?: boolean;
  transformError?: (error: TsdevError) => TsdevError;
}

export function withErrorRecovery(options: ErrorRecoveryOptions = {}): Policy {
  return <TInput, TOutput>(handler: Handler<TInput, TOutput>): Handler<TInput, TOutput> => {
    return async (input, context) => {
      try {
        return await handler(input, context);
      } catch (error) {
        const tsdevError = error instanceof TsdevError 
          ? error 
          : new ExecutionError(error.message);
        
        if (options.logErrors) {
          console.error('[ErrorRecovery]', tsdevError.toJSON());
        }
        
        if (options.transformError) {
          throw options.transformError(tsdevError);
        }
        
        if (options.fallback) {
          return options.fallback(tsdevError, input) as TOutput;
        }
        
        throw tsdevError;
      }
    };
  };
}
```

---

### 3. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å (HIGH PRIORITY)

#### –ü—Ä–æ–±–ª–µ–º–∞
- –ù–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏/–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
- –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç input sanitization
- –ù–µ—Ç rate limiting –Ω–∞ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–º —É—Ä–æ–≤–Ω–µ
- –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç audit logging

#### –†–µ—à–µ–Ω–∏–µ

**3.1. –°–∏—Å—Ç–µ–º–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏**

```typescript
// packages/security/src/auth.ts

export interface User {
  id: string;
  email: string;
  roles: string[];
  permissions: string[];
}

export interface AuthContext {
  user?: User;
  token?: string;
  sessionId?: string;
}

// Add auth to ExecutionContext
declare module '@tsdev/core' {
  interface ExecutionContext {
    auth?: AuthContext;
  }
}

// Auth policy
export function withAuth(options: {
  required?: boolean;
  roles?: string[];
  permissions?: string[];
}): Policy {
  return <TInput, TOutput>(handler: Handler<TInput, TOutput>): Handler<TInput, TOutput> => {
    return async (input, context) => {
      const { auth } = context;
      
      // Check if auth is required
      if (options.required && !auth?.user) {
        throw new AuthenticationError('Authentication required');
      }
      
      // Check roles
      if (options.roles && auth?.user) {
        const hasRole = options.roles.some(role => 
          auth.user?.roles.includes(role)
        );
        if (!hasRole) {
          throw new AuthorizationError('Insufficient role');
        }
      }
      
      // Check permissions
      if (options.permissions && auth?.user) {
        const hasPermission = options.permissions.every(perm =>
          auth.user?.permissions.includes(perm)
        );
        if (!hasPermission) {
          throw new AuthorizationError('Insufficient permissions');
        }
      }
      
      return handler(input, context);
    };
  };
}

// JWT verification helper
export async function verifyJWT(token: string): Promise<User> {
  // Implement JWT verification
  // This is a placeholder - use proper JWT library
  throw new Error('Not implemented');
}
```

**3.2. Input sanitization policy**

```typescript
// packages/security/src/sanitization.ts
import DOMPurify from 'isomorphic-dompurify';

export interface SanitizationOptions {
  html?: boolean;
  sql?: boolean;
  maxLength?: number;
}

export function withSanitization(options: SanitizationOptions = {}): Policy {
  return <TInput, TOutput>(handler: Handler<TInput, TOutput>): Handler<TInput, TOutput> => {
    return async (input, context) => {
      const sanitized = sanitizeInput(input, options);
      return handler(sanitized as TInput, context);
    };
  };
}

function sanitizeInput(input: unknown, options: SanitizationOptions): unknown {
  if (typeof input === 'string') {
    let result = input;
    
    // HTML sanitization
    if (options.html) {
      result = DOMPurify.sanitize(result);
    }
    
    // SQL injection prevention
    if (options.sql) {
      result = result.replace(/['";\\]/g, '');
    }
    
    // Length limit
    if (options.maxLength) {
      result = result.slice(0, options.maxLength);
    }
    
    return result;
  }
  
  if (Array.isArray(input)) {
    return input.map(item => sanitizeInput(item, options));
  }
  
  if (input && typeof input === 'object') {
    const sanitized: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(input)) {
      sanitized[key] = sanitizeInput(value, options);
    }
    return sanitized;
  }
  
  return input;
}
```

**3.3. Audit logging**

```typescript
// packages/security/src/audit.ts

export interface AuditEvent {
  timestamp: Date;
  userId?: string;
  action: string;
  resource: string;
  metadata: Record<string, unknown>;
  success: boolean;
  error?: string;
}

export interface AuditLogger {
  log(event: AuditEvent): Promise<void>;
}

export function withAuditLog(logger: AuditLogger): Policy {
  return <TInput, TOutput>(handler: Handler<TInput, TOutput>): Handler<TInput, TOutput> => {
    return async (input, context) => {
      const startTime = Date.now();
      let success = false;
      let error: string | undefined;
      
      try {
        const result = await handler(input, context);
        success = true;
        return result;
      } catch (err) {
        error = err instanceof Error ? err.message : String(err);
        throw err;
      } finally {
        await logger.log({
          timestamp: new Date(),
          userId: context.auth?.user?.id,
          action: 'procedure.execute',
          resource: context.metadata.procedureName as string,
          metadata: {
            requestId: context.requestId,
            executionTime: Date.now() - startTime,
            transport: context.metadata.transport,
          },
          success,
          error,
        });
      }
    };
  };
}
```

---

### 4. –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ (MEDIUM PRIORITY)

#### –†–µ—à–µ–Ω–∏–µ

**4.1. –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ**

```typescript
// packages/policies/src/withCache.ts
import type { Policy } from '@tsdev/core';

export interface CacheOptions {
  ttl?: number; // Time to live in ms
  keyFn?: (input: unknown) => string;
  storage?: CacheStorage;
}

export interface CacheStorage {
  get(key: string): Promise<unknown | null>;
  set(key: string, value: unknown, ttl: number): Promise<void>;
  delete(key: string): Promise<void>;
}

// In-memory cache implementation
class MemoryCache implements CacheStorage {
  private cache = new Map<string, { value: unknown; expires: number }>();
  
  async get(key: string): Promise<unknown | null> {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value;
  }
  
  async set(key: string, value: unknown, ttl: number): Promise<void> {
    this.cache.set(key, {
      value,
      expires: Date.now() + ttl,
    });
  }
  
  async delete(key: string): Promise<void> {
    this.cache.delete(key);
  }
}

export function withCache(options: CacheOptions = {}): Policy {
  const {
    ttl = 60000, // 1 minute default
    keyFn = (input) => JSON.stringify(input),
    storage = new MemoryCache(),
  } = options;
  
  return <TInput, TOutput>(handler: Handler<TInput, TOutput>): Handler<TInput, TOutput> => {
    return async (input, context) => {
      const cacheKey = keyFn(input);
      
      // Try to get from cache
      const cached = await storage.get(cacheKey);
      if (cached !== null) {
        console.log(`[Cache] HIT: ${cacheKey}`);
        return cached as TOutput;
      }
      
      console.log(`[Cache] MISS: ${cacheKey}`);
      
      // Execute handler
      const result = await handler(input, context);
      
      // Store in cache
      await storage.set(cacheKey, result, ttl);
      
      return result;
    };
  };
}
```

**4.2. Request batching**

```typescript
// packages/core/src/batching.ts

export interface BatchRequest {
  id: string;
  procedureName: string;
  input: unknown;
}

export interface BatchResponse {
  id: string;
  result?: unknown;
  error?: {
    code: string;
    message: string;
  };
}

export async function executeBatch(
  requests: BatchRequest[],
  registry: Registry,
  context: ExecutionContext
): Promise<BatchResponse[]> {
  // Execute all requests in parallel
  const results = await Promise.allSettled(
    requests.map(async (req) => {
      const procedure = registry.get(req.procedureName);
      if (!procedure) {
        throw new ProcedureNotFoundError(req.procedureName);
      }
      
      const result = await executeProcedure(procedure, req.input, context);
      return { id: req.id, result };
    })
  );
  
  return results.map((result, index) => {
    const req = requests[index];
    if (result.status === 'fulfilled') {
      return result.value;
    } else {
      return {
        id: req.id,
        error: {
          code: 'EXECUTION_ERROR',
          message: result.reason.message,
        },
      };
    }
  });
}
```

**4.3. Connection pooling –¥–ª—è workflow**

```typescript
// packages/workflow/src/pool.ts

export class WorkflowExecutionPool {
  private activeExecutions = new Map<string, Promise<WorkflowExecutionResult>>();
  private maxConcurrent = 10;
  
  async execute(
    workflow: WorkflowDefinition,
    registry: Registry,
    input: Record<string, unknown>
  ): Promise<WorkflowExecutionResult> {
    // Wait if pool is full
    while (this.activeExecutions.size >= this.maxConcurrent) {
      await Promise.race(this.activeExecutions.values());
    }
    
    const executionId = generateExecutionId();
    const promise = executeWorkflow(workflow, registry, input);
    
    this.activeExecutions.set(executionId, promise);
    
    try {
      return await promise;
    } finally {
      this.activeExecutions.delete(executionId);
    }
  }
}
```

---

### 5. Developer Experience (MEDIUM PRIORITY)

#### –†–µ—à–µ–Ω–∏–µ

**5.1. CLI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏**

```typescript
// packages/cli/src/commands/dev.ts

export function createDevCLI() {
  return {
    name: 'tsdev',
    commands: {
      // Generate new procedure
      generate: {
        procedure: async (name: string) => {
          const [resource, action] = name.split('.');
          
          // Generate contract file
          const contractPath = `src/contracts/${resource}.ts`;
          // Generate handler file
          const handlerPath = `src/handlers/${resource}.ts`;
          
          // Create files with templates
          console.log(`‚úì Created ${contractPath}`);
          console.log(`‚úì Created ${handlerPath}`);
        },
        
        // Generate adapter
        adapter: async (type: 'grpc' | 'graphql' | 'websocket') => {
          console.log(`Generating ${type} adapter...`);
        },
      },
      
      // Validate contracts
      validate: async () => {
        const registry = await collectRegistry();
        const errors: string[] = [];
        
        for (const [name, proc] of registry) {
          // Check naming conventions
          if (!name.includes('.')) {
            errors.push(`${name}: should follow 'resource.action' convention`);
          }
          
          // Validate schemas
          try {
            proc.contract.input.parse({});
          } catch (e) {
            // Schema is valid
          }
        }
        
        if (errors.length > 0) {
          console.error('Validation errors:', errors);
          process.exit(1);
        }
        
        console.log('‚úì All contracts valid');
      },
      
      // Introspection
      list: async () => {
        const registry = await collectRegistry();
        console.log('Registered procedures:');
        for (const [name, proc] of registry) {
          console.log(`  - ${name}: ${proc.contract.description || 'No description'}`);
        }
      },
    },
  };
}
```

**5.2. VSCode extension stub**

```typescript
// packages/vscode/src/extension.ts

export function activate(context: vscode.ExtensionContext) {
  // Auto-complete –¥–ª—è procedure names
  const procedureCompletion = vscode.languages.registerCompletionItemProvider(
    'typescript',
    {
      async provideCompletionItems(document, position) {
        // Scan registry and provide completions
        const registry = await collectRegistry();
        return Array.from(registry.keys()).map(name => {
          const item = new vscode.CompletionItem(name);
          item.kind = vscode.CompletionItemKind.Function;
          return item;
        });
      },
    }
  );
  
  context.subscriptions.push(procedureCompletion);
  
  // Hover information
  const hoverProvider = vscode.languages.registerHoverProvider('typescript', {
    async provideHover(document, position) {
      // Show contract info on hover
    },
  });
  
  context.subscriptions.push(hoverProvider);
}
```

**5.3. Schema visualization**

```typescript
// packages/devtools/src/schema-viewer.ts

export function generateSchemaHTML(contract: Contract): string {
  // Convert Zod schema to visual representation
  return `
    <div class="schema">
      <h3>${contract.name}</h3>
      <div class="input">
        <h4>Input</h4>
        ${zodSchemaToHTML(contract.input)}
      </div>
      <div class="output">
        <h4>Output</h4>
        ${zodSchemaToHTML(contract.output)}
      </div>
    </div>
  `;
}
```

---

### 6. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞–¥–∞–ø—Ç–µ—Ä—ã (LOW-MEDIUM PRIORITY)

#### –†–µ—à–µ–Ω–∏–µ

**6.1. GraphQL –∞–¥–∞–ø—Ç–µ—Ä**

```typescript
// packages/adapters/src/graphql.ts
import { GraphQLSchema, GraphQLObjectType } from 'graphql';

export function createGraphQLSchema(registry: Registry): GraphQLSchema {
  // Convert procedures to GraphQL queries/mutations
  const queryFields = {};
  const mutationFields = {};
  
  for (const [name, procedure] of registry) {
    const [resource, action] = name.split('.');
    
    // Read operations -> queries
    if (['get', 'list', 'search'].includes(action)) {
      queryFields[name] = createGraphQLField(procedure);
    } else {
      // Write operations -> mutations
      mutationFields[name] = createGraphQLField(procedure);
    }
  }
  
  return new GraphQLSchema({
    query: new GraphQLObjectType({
      name: 'Query',
      fields: queryFields,
    }),
    mutation: new GraphQLObjectType({
      name: 'Mutation',
      fields: mutationFields,
    }),
  });
}
```

**6.2. gRPC –∞–¥–∞–ø—Ç–µ—Ä**

```typescript
// packages/adapters/src/grpc.ts

export function createGRPCService(registry: Registry) {
  // Generate .proto file from contracts
  const protoContent = generateProtoFile(registry);
  
  // Create gRPC server
  const server = new grpc.Server();
  
  // Add services
  for (const [name, procedure] of registry) {
    server.addService(/* ... */);
  }
  
  return server;
}
```

**6.3. WebSocket –∞–¥–∞–ø—Ç–µ—Ä**

```typescript
// packages/adapters/src/websocket.ts
import { WebSocketServer } from 'ws';

export function createWebSocketServer(registry: Registry, port: number) {
  const wss = new WebSocketServer({ port });
  
  wss.on('connection', (ws) => {
    ws.on('message', async (data) => {
      const { id, procedure, input } = JSON.parse(data.toString());
      
      try {
        const proc = registry.get(procedure);
        if (!proc) {
          throw new ProcedureNotFoundError(procedure);
        }
        
        const context = createExecutionContext({
          transport: 'websocket',
        });
        
        const result = await executeProcedure(proc, input, context);
        
        ws.send(JSON.stringify({ id, result }));
      } catch (error) {
        ws.send(JSON.stringify({
          id,
          error: error.message,
        }));
      }
    });
  });
  
  return wss;
}
```

---

### 7. SDK Generation (MEDIUM PRIORITY)

#### –†–µ—à–µ–Ω–∏–µ

```typescript
// packages/generators/src/sdk.ts

export function generateTypeScriptSDK(
  registry: Registry,
  options: { packageName: string }
): string {
  const procedures = Array.from(registry.entries());
  
  return `
// Generated TypeScript SDK
import { z } from 'zod';

export class ${options.packageName}Client {
  constructor(private baseUrl: string) {}
  
  ${procedures.map(([name, proc]) => `
  async ${name.replace('.', '_')}(
    input: z.infer<typeof ${name}InputSchema>
  ): Promise<z.infer<typeof ${name}OutputSchema>> {
    const response = await fetch(\`\${this.baseUrl}/rpc/${name}\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input),
    });
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    return response.json();
  }
  `).join('\n')}
}

// Export schemas
${procedures.map(([name, proc]) => `
export const ${name}InputSchema = ${zodToString(proc.contract.input)};
export const ${name}OutputSchema = ${zodToString(proc.contract.output)};
`).join('\n')}
  `;
}

export function generatePythonSDK(registry: Registry): string {
  // Generate Python SDK using dataclasses and requests
  return `
import requests
from dataclasses import dataclass
from typing import Any

class TsdevClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
    
    def call_procedure(self, name: str, input: dict) -> dict:
        response = requests.post(
            f"{self.base_url}/rpc/{name}",
            json=input
        )
        response.raise_for_status()
        return response.json()
  `;
}
```

---

### 8. Contract Versioning (MEDIUM PRIORITY)

#### –†–µ—à–µ–Ω–∏–µ

```typescript
// packages/core/src/versioning.ts

export interface VersionedContract extends Contract {
  version: string;
  deprecated?: boolean;
  deprecationMessage?: string;
  replacedBy?: string;
}

export interface ContractMigration {
  from: string;
  to: string;
  migrateInput: (input: unknown) => unknown;
  migrateOutput: (output: unknown) => unknown;
}

export class VersionedRegistry {
  private contracts = new Map<string, Map<string, VersionedContract>>();
  private migrations = new Map<string, ContractMigration[]>();
  
  register(contract: VersionedContract) {
    const versions = this.contracts.get(contract.name) || new Map();
    versions.set(contract.version, contract);
    this.contracts.set(contract.name, versions);
  }
  
  get(name: string, version?: string): VersionedContract | undefined {
    const versions = this.contracts.get(name);
    if (!versions) return undefined;
    
    if (version) {
      return versions.get(version);
    }
    
    // Return latest version
    return Array.from(versions.values())
      .sort((a, b) => b.version.localeCompare(a.version))[0];
  }
  
  addMigration(migration: ContractMigration) {
    const migrations = this.migrations.get(migration.from) || [];
    migrations.push(migration);
    this.migrations.set(migration.from, migrations);
  }
}
```

---

## üìã –ü–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è (Roadmap)

### Phase 1: –§—É–Ω–¥–∞–º–µ–Ω—Ç (1-2 –Ω–µ–¥–µ–ª–∏)
1. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É
2. ‚úÖ –°–æ–∑–¥–∞—Ç—å —Å–∏—Å—Ç–µ–º—É typed errors
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –±–∞–∑–æ–≤—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é/–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
4. ‚úÖ –ù–∞–ø–∏—Å–∞—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è core –∏ workflow –ø–∞–∫–µ—Ç–æ–≤

### Phase 2: –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (1-2 –Ω–µ–¥–µ–ª–∏)
1. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å audit logging
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å caching policy
3. ‚úÖ –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å input sanitization
4. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å request batching

### Phase 3: Developer Experience (1 –Ω–µ–¥–µ–ª—è)
1. ‚úÖ –°–æ–∑–¥–∞—Ç—å CLI –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å validation –∫–æ–º–∞–Ω–¥—ã
3. ‚úÖ –£–ª—É—á—à–∏—Ç—å error messages
4. ‚úÖ –°–æ–∑–¥–∞—Ç—å dev-mode —Å hot reload

### Phase 4: –†–∞—Å—à–∏—Ä–µ–Ω–∏—è (2-3 –Ω–µ–¥–µ–ª–∏)
1. ‚úÖ GraphQL –∞–¥–∞–ø—Ç–µ—Ä
2. ‚úÖ gRPC –∞–¥–∞–ø—Ç–µ—Ä
3. ‚úÖ WebSocket –∞–¥–∞–ø—Ç–µ—Ä
4. ‚úÖ SDK generation (TypeScript, Python)

### Phase 5: Production-ready (1-2 –Ω–µ–¥–µ–ª–∏)
1. ‚úÖ Contract versioning
2. ‚úÖ Distributed tracing improvements
3. ‚úÖ Health checks –∏ metrics
4. ‚úÖ Production documentation

---

## üéØ –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

–ü–æ—Å–ª–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è —É–ª—É—á—à–µ–Ω–∏–π:

- **–¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ**: ‚â•80% –¥–ª—è –≤—Å–µ—Ö –ø–∞–∫–µ—Ç–æ–≤
- **Type safety**: 100% TypeScript strict mode
- **Security**: –í—Å–µ OWASP Top 10 –ø–æ–∫—Ä—ã—Ç—ã
- **Performance**: <100ms latency –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–æ—Ü–µ–¥—É—Ä
- **DX**: –í—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –ø—Ä–æ—Ü–µ–¥—É—Ä—ã <5 –º–∏–Ω—É—Ç
- **Documentation**: 100% API coverage
- **Production readiness**: Zero downtime deployments

---

## üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

### –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è –Ω–æ–≤—ã—Ö –ø–∞–∫–µ—Ç–æ–≤

```json
{
  "@tsdev/testing": {
    "dependencies": ["vitest", "@vitest/coverage-v8"]
  },
  "@tsdev/security": {
    "dependencies": [
      "jsonwebtoken",
      "bcrypt",
      "isomorphic-dompurify",
      "helmet"
    ]
  },
  "@tsdev/cli": {
    "dependencies": [
      "commander",
      "chalk",
      "inquirer"
    ]
  }
}
```

### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è production

```typescript
// config/production.ts
export const productionConfig = {
  // –û—Ç–∫–ª—é—á–∏—Ç—å output validation –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  disableOutputValidation: true,
  
  // –í–∫–ª—é—á–∏—Ç—å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
  enableCaching: true,
  cacheGTL: 60000,
  
  // Rate limiting
  rateLimit: {
    maxTokens: 100,
    refillRate: 10,
  },
  
  // Tracing sampling
  tracingSampleRate: 0.1, // 10%
  
  // Security
  auth: {
    required: true,
    jwtSecret: process.env.JWT_SECRET,
  },
};
```

---

## üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

### 1. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–ª–µ—Ä—Ç—ã
- –ù–∞—Å—Ç—Ä–æ–∏—Ç—å Prometheus metrics export
- –î–æ–±–∞–≤–∏—Ç—å Grafana dashboards
- –ù–∞—Å—Ç—Ä–æ–∏—Ç—å alerting –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫

### 2. –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- –°–æ–∑–¥–∞—Ç—å interactive playground (Swagger-like)
- –î–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –ø—Ä–∏–º–µ—Ä–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
- –°–æ–∑–¥–∞—Ç—å migration guides

### 3. –≠–∫–æ—Å–∏—Å—Ç–µ–º–∞
- –°–æ–∑–¥–∞—Ç—å marketplace –¥–ª—è –ø–ª–∞–≥–∏–Ω–æ–≤
- –î–æ–±–∞–≤–∏—Ç—å community templates
- –û—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å showcase –ø—Ä–æ–µ–∫—Ç–æ–≤

### 4. CI/CD
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç–µ—Å—Ç—ã –Ω–∞ –∫–∞–∂–¥—ã–π PR
- Semantic versioning –¥–ª—è —Ä–µ–ª–∏–∑–æ–≤
- Automated changelog generation

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–µ–≤—Ä–∞—Ç—è—Ç tsdev –∏–∑ proof-of-concept –≤ production-ready —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è, —Å–æ—Ö—Ä–∞–Ω—è—è –ø—Ä–∏ —ç—Ç–æ–º –µ–≥–æ —Ñ–∏–ª–æ—Å–æ—Ñ–∏—é contracts-first –∏ zero-boilerplate –ø–æ–¥—Ö–æ–¥–∞.

**–ì–ª–∞–≤–Ω—ã–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã:**
1. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ** - –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
2. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è production
3. **Error handling** - —É–ª—É—á—à–∏—Ç debugging experience
4. **Developer tools** - —É—Å–∫–æ—Ä–∏—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É

–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–π–º–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ **6-8 –Ω–µ–¥–µ–ª—å** –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –æ–¥–Ω–æ–≥–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞, –∏–ª–∏ **3-4 –Ω–µ–¥–µ–ª–∏** –ø—Ä–∏ –∫–æ–º–∞–Ω–¥–µ –∏–∑ 2-3 —á–µ–ª–æ–≤–µ–∫.
