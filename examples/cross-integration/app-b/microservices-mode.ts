/**
 * MICROSERVICES MODE - After c4c integrate
 * 
 * This demonstrates the SAME workflow running across microservices
 * with ZERO CHANGES to the workflow code!
 * 
 * After running: c4c integrate notification-service
 * 
 * The workflow now:
 * 1. Receives webhook from app-a
 * 2. Executes same workflow
 * 3. Uses integrated procedures automatically
 */

import { createRegistry } from '@c4c/core';
import { createHttpServer, WebhookRegistry } from '@c4c/adapters';
import { registerTriggerHandler } from '@c4c/workflow';

// Import notification procedures (app-b native)
import { NotificationProcedures } from './procedures/notifications.js';

// Import integrated procedures from app-a (generated by c4c integrate)
// These are in: app-b/procedures/integrations/task-manager/
import * as TaskManagerIntegration from './procedures/integrations/task-manager/procedures.gen.js';

// Import the SAME workflow (identical code!)
// This could be shared via npm package or copied
import { taskNotificationWorkflow } from '../app-a/workflows/task-notification-workflow.js';

// Create registry
const registry = createRegistry();

console.log('üåê MICROSERVICES MODE - App B with Integration\n');
console.log('‚îÅ'.repeat(60));

// Register app-b native procedures
console.log('\nüì¶ Registering app-b procedures...\n');
for (const proc of NotificationProcedures) {
  registry.register(proc);
  console.log(`  ‚úì ${proc.contract.name}`);
}

// Register integrated procedures from app-a
console.log('\nüîó Registering integrated procedures (from app-a)...\n');
for (const proc of Object.values(TaskManagerIntegration)) {
  if (proc && typeof proc === 'object' && 'contract' in proc) {
    registry.register(proc as any);
    console.log(`  ‚úì ${proc.contract.name} (integrated)`);
  }
}

// Register the SAME workflow
console.log('\nüîÑ Registering workflow (IDENTICAL to monolith!)...\n');
registerTriggerHandler(
  'tasks.trigger.created',
  taskNotificationWorkflow,
  registry
);
console.log(`  ‚úì ${taskNotificationWorkflow.name}`);
console.log('  üí° This is THE SAME workflow code as in monolith!');

// Setup webhook registry
const webhookRegistry = new WebhookRegistry();

webhookRegistry.registerHandler('tasks', async (event) => {
  console.log('\nüì® [Webhook] Received event from app-a:');
  console.log(`   Event: ${event.eventType}`);
  console.log(`   Provider: ${event.provider}`);
  console.log(`   Payload:`, event.payload);
  
  // Webhook will automatically trigger the workflow via tasks.trigger.created
});

// Start HTTP server
const PORT = Number(process.env.PORT) || 3001;

const server = createHttpServer(registry, PORT, {
  enableWebhooks: true,
  webhookRegistry,
  enableDocs: true,
  enableRpc: true,
});

console.log('\n‚îÅ'.repeat(60));
console.log('\n‚ú® Microservices setup complete!\n');
console.log(`üöÄ Server started on http://localhost:${PORT}`);
console.log('\nüìö Endpoints:');
console.log(`   Docs:     http://localhost:${PORT}/docs`);
console.log(`   Webhook:  POST http://localhost:${PORT}/webhooks/tasks`);
console.log('\nüí° How to test:');
console.log('   1. Send webhook from app-a to app-b');
console.log('   2. App-b receives webhook ‚Üí triggers workflow');
console.log('   3. Workflow calls integrated app-a procedures');
console.log('   4. Workflow calls native app-b procedures');
console.log('   5. All with SAME workflow code as monolith!');
console.log('\n‚îÅ'.repeat(60));

/**
 * WHAT CHANGED FROM MONOLITH?
 * 
 * App-A (task service):
 * - Changed: trigger exposure 'internal' ‚Üí 'external'
 * - Changed: emitTriggerEvent() ‚Üí POST webhook
 * - Unchanged: workflow code
 * 
 * App-B (notification service):
 * - Added: integrated procedures via c4c integrate
 * - Added: webhook endpoint
 * - Unchanged: workflow code (IDENTICAL!)
 * 
 * KEY INSIGHT:
 * The workflow definition is 100% portable!
 * No changes needed when moving to microservices.
 */
