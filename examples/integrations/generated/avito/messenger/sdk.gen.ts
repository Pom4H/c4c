// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options as ClientOptions,
  type Client,
  type TDataShape,
  formDataBodySerializer
} from './client'
import type {
  PostSendMessageData,
  PostSendMessageResponses,
  PostSendImageMessageData,
  PostSendImageMessageResponses,
  DeleteMessageData,
  DeleteMessageResponses,
  ChatReadData,
  ChatReadResponses,
  GetVoiceFilesData,
  GetVoiceFilesResponses,
  UploadImagesData,
  UploadImagesResponses,
  GetSubscriptionsData,
  GetSubscriptionsResponses,
  PostWebhookUnsubscribeData,
  PostWebhookUnsubscribeResponses,
  PostBlacklistV2Data,
  PostBlacklistV2Responses,
  GetChatsV2Data,
  GetChatsV2Responses,
  GetChatByIdV2Data,
  GetChatByIdV2Responses,
  GetMessagesV3Data,
  GetMessagesV3Responses,
  PostWebhookV3Data,
  PostWebhookV3Responses
} from './types.gen'
import { client } from './client.gen'
import { getMessagesV3ResponseTransformer } from './transformers.gen'

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean
> = ClientOptions<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>
}

/**
 * Отправка сообщения
 * На данный момент можно отправить только текстовое сообщение
 *
 */
export const postSendMessage = <ThrowOnError extends boolean = false>(
  options: Options<PostSendMessageData, ThrowOnError>
) => {
  return (options.client ?? client).post<PostSendMessageResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/chats/{chat_id}/messages',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })
}

/**
 * Отправка сообщения с изображением
 * Метод используется для отправки сообщения с изображением.
 *
 * Для отправки сообщения с изображением необходимо передать в запросе id изображения, полученного после загрузки.
 *
 */
export const postSendImageMessage = <ThrowOnError extends boolean = false>(
  options: Options<PostSendImageMessageData, ThrowOnError>
) => {
  return (options.client ?? client).post<PostSendImageMessageResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/chats/{chat_id}/messages/image',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })
}

/**
 * Удаление сообщения
 * Сообщение не пропадает из истории, а меняет свой тип на deleted.
 * Удалять сообщения можно не позднее часа с момента их отправки.
 *
 */
export const deleteMessage = <ThrowOnError extends boolean = false>(
  options: Options<DeleteMessageData, ThrowOnError>
) => {
  return (options.client ?? client).post<DeleteMessageResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/chats/{chat_id}/messages/{message_id}',
    ...options
  })
}

/**
 * Прочитать чат
 * После успешного получения списка сообщений необходимо вызвать этот метод для того, чтобы чат стал прочитанным.
 *
 */
export const chatRead = <ThrowOnError extends boolean = false>(
  options: Options<ChatReadData, ThrowOnError>
) => {
  return (options.client ?? client).post<ChatReadResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/chats/{chat_id}/read',
    ...options
  })
}

/**
 * Получение голосовых сообщений
 * Метод используется для получения ссылки на файл с голосовым сообщением по идентификатору voice_id, получаемому из тела сообщения с типом voice.
 *
 * Особенности работы с голосовыми сообщениями:
 * - Голосовые сообщения Авито используют кодек **[opus](https://ru.wikipedia.org/wiki/Opus_(%D0%BA%D0%BE%D0%B4%D0%B5%D0%BA))** внутри **.mp4** контейнера;
 * - Ссылка на голосовое сообщение доступна в течение **одного часа** с момента запроса. Попытка получить файл по ссылке спустя это время приведёт к ошибке. Для восстановления доступа необходимо получить новую ссылку на файл;
 * - Как и с обычными сообщениями, получение ссылки на файл доступно только для пользователей, находящихся в беседе, где голосовое сообщение было отправлено;
 *
 */
export const getVoiceFiles = <ThrowOnError extends boolean = false>(
  options: Options<GetVoiceFilesData, ThrowOnError>
) => {
  return (options.client ?? client).get<GetVoiceFilesResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/getVoiceFiles',
    ...options
  })
}

/**
 * Загрузка изображений
 * Метод используется для загрузки изображений в формате JPEG, HEIC, GIF, BMP или PNG.
 *
 * Особенности работы с загрузкой изображений:
 * - Метод поддерживает только одиночные изображения; для загрузки нескольких картинок необходимо сделать несколько запросов;
 * - Максимальный размер файла — 24 МБ;
 * - Максимальное разрешение — 75 мегапиксилей;
 *
 */
export const uploadImages = <ThrowOnError extends boolean = false>(
  options: Options<UploadImagesData, ThrowOnError>
) => {
  return (options.client ?? client).post<UploadImagesResponses, unknown, ThrowOnError>({
    ...formDataBodySerializer,
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/accounts/{user_id}/uploadImages',
    ...options,
    headers: {
      'Content-Type': null,
      ...options.headers
    }
  })
}

/**
 * Получение подписок (webhooks)
 * Получение списка подписок
 *
 */
export const getSubscriptions = <ThrowOnError extends boolean = false>(
  options?: Options<GetSubscriptionsData, ThrowOnError>
) => {
  return (options?.client ?? client).post<GetSubscriptionsResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/subscriptions',
    ...options
  })
}

/**
 * Отключение уведомлений (webhooks)
 * Отключение уведомлений
 *
 */
export const postWebhookUnsubscribe = <ThrowOnError extends boolean = false>(
  options?: Options<PostWebhookUnsubscribeData, ThrowOnError>
) => {
  return (options?.client ?? client).post<PostWebhookUnsubscribeResponses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v1/webhook/unsubscribe',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    }
  })
}

/**
 * Добавление пользователя в blacklist
 * Добавление пользователя в blacklist
 *
 */
export const postBlacklistV2 = <ThrowOnError extends boolean = false>(
  options: Options<PostBlacklistV2Data, ThrowOnError>
) => {
  return (options.client ?? client).post<PostBlacklistV2Responses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v2/accounts/{user_id}/blacklist',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })
}

/**
 * Получение информации по чатам
 * Возвращает список чатов
 *
 */
export const getChatsV2 = <ThrowOnError extends boolean = false>(
  options: Options<GetChatsV2Data, ThrowOnError>
) => {
  return (options.client ?? client).get<GetChatsV2Responses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v2/accounts/{user_id}/chats',
    ...options
  })
}

/**
 * Получение информации по чату
 * Возвращает данные чата и последнее сообщение в нем
 *
 */
export const getChatByIdV2 = <ThrowOnError extends boolean = false>(
  options: Options<GetChatByIdV2Data, ThrowOnError>
) => {
  return (options.client ?? client).get<GetChatByIdV2Responses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v2/accounts/{user_id}/chats/{chat_id}',
    ...options
  })
}

/**
 * Получение списка сообщений V3
 * Получение списка сообщений.  **Не помечает чат прочитанным.**
 * После успешного получения списка сообщений необходимо вызвать [метод](https://api.avito.ru/docs/api.html#operation/chatRead), который сделает сообщения прочитанными.
 * Для получения новых сообщений в реальном времени используйте [webhooks](https://api.avito.ru/docs/api.html#operation/postWebhookV3)
 *
 */
export const getMessagesV3 = <ThrowOnError extends boolean = false>(
  options: Options<GetMessagesV3Data, ThrowOnError>
) => {
  return (options.client ?? client).get<GetMessagesV3Responses, unknown, ThrowOnError>({
    responseTransformer: getMessagesV3ResponseTransformer,
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v3/accounts/{user_id}/chats/{chat_id}/messages/',
    ...options
  })
}

/**
 * Включение уведомлений V3 (webhooks)
 * Включение webhook-уведомлений.
 *
 * Схему JSON приходящего в webhook сообщения можно увидеть в примерах ответов.
 *
 * После регистрации url'а для получения веб-хуков, убедитесь, что он доступен, работает и возвращает статус 200 ОК соблюдая timeout 2s,
 * например, выполнив запрос:
 *
 * curl --connect-timeout 2 <url-вашего-вебхука> -i -d '{}'
 *
 */
export const postWebhookV3 = <ThrowOnError extends boolean = false>(
  options?: Options<PostWebhookV3Data, ThrowOnError>
) => {
  return (options?.client ?? client).post<PostWebhookV3Responses, unknown, ThrowOnError>({
    security: [
      {
        scheme: 'bearer',
        type: 'http'
      },
      {
        scheme: 'bearer',
        type: 'http'
      }
    ],
    url: '/messenger/v3/webhook',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers
    }
  })
}
