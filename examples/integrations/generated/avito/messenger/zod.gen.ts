// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zChat = z.object({
  context: z.optional(
    z.object({
      type: z.optional(z.string()),
      value: z.optional(
        z.object({
          id: z.optional(z.int()),
          images: z.optional(
            z.object({
              count: z.optional(z.int()),
              main: z.optional(
                z.object({
                  '140x105': z.optional(z.string())
                })
              )
            })
          ),
          price_string: z.optional(z.string()),
          status_id: z.optional(z.int()),
          title: z.optional(z.string()),
          url: z.optional(z.string()),
          user_id: z.optional(z.int())
        })
      )
    })
  ),
  created: z.optional(z.int()),
  id: z.optional(z.string()),
  last_message: z.optional(
    z.object({
      author_id: z.optional(z.int()),
      content: z.optional(
        z.object({
          link: z.optional(
            z.object({
              text: z.optional(z.string()),
              url: z.optional(z.string())
            })
          )
        })
      ),
      created: z.optional(z.int()),
      direction: z.optional(z.string()),
      id: z.optional(z.string()),
      type: z.optional(z.string())
    })
  ),
  updated: z.optional(z.int()),
  users: z.optional(
    z.array(
      z.object({
        id: z.optional(z.int()),
        name: z.optional(z.string()),
        public_user_profile: z.optional(
          z.object({
            avatar: z.optional(
              z.object({
                default: z.optional(z.string()),
                images: z.optional(
                  z.object({
                    '128x128': z.optional(z.string()),
                    '192x192': z.optional(z.string()),
                    '24x24': z.optional(z.string()),
                    '256x256': z.optional(z.string()),
                    '36x36': z.optional(z.string()),
                    '48x48': z.optional(z.string()),
                    '64x64': z.optional(z.string()),
                    '72x72': z.optional(z.string()),
                    '96x96': z.optional(z.string())
                  })
                )
              })
            ),
            item_id: z.optional(z.int()),
            url: z.optional(z.string()),
            user_id: z.optional(z.int())
          })
        )
      })
    )
  )
})

export const zChats = z.object({
  chats: z.optional(z.array(zChat))
})

/**
 * Для сообщений типов "appCall" "file" "video" возвращается empty object (данные типы не поддерживаются)
 */
export const zMessageContent = z.object({
  call: z.optional(
    z.union([
      z.object({
        status: z.optional(z.enum(['missed'])),
        target_user_id: z.optional(z.coerce.bigint())
      }),
      z.null()
    ])
  ),
  flow_id: z.optional(z.union([z.string(), z.null()])),
  image: z.optional(
    z.union([
      z.object({
        sizes: z.optional(z.record(z.string(), z.unknown()))
      }),
      z.null()
    ])
  ),
  item: z.optional(
    z.union([
      z.object({
        image_url: z.optional(z.string()),
        item_url: z.optional(z.string()),
        price_string: z.optional(z.union([z.string(), z.null()])),
        title: z.optional(z.string())
      }),
      z.null()
    ])
  ),
  link: z.optional(
    z.union([
      z.object({
        preview: z.optional(
          z.union([
            z.object({
              description: z.optional(z.string()),
              domain: z.optional(z.string()),
              images: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
              title: z.optional(z.string()),
              url: z.optional(z.string())
            }),
            z.null()
          ])
        ),
        text: z.optional(z.string()),
        url: z.optional(z.string())
      }),
      z.null()
    ])
  ),
  location: z.optional(
    z.union([
      z.object({
        kind: z.optional(z.enum(['house', 'street', 'area', '...'])),
        lat: z.optional(z.number()),
        lon: z.optional(z.number()),
        text: z.optional(z.string()),
        title: z.optional(z.string())
      }),
      z.null()
    ])
  ),
  text: z.optional(z.union([z.string(), z.null()])),
  voice: z.optional(
    z.union([
      z.object({
        voice_id: z.optional(z.string())
      }),
      z.null()
    ])
  )
})

/**
 * цитируемое сообщение
 */
export const zMessageQuote = z.object({
  author_id: z.optional(z.coerce.bigint()),
  content: z.optional(zMessageContent),
  created: z.optional(z.coerce.bigint()),
  id: z.optional(z.string()),
  type: z.optional(
    z.enum(['text', 'image', 'link', 'item', 'location', 'call', 'deleted', 'voice'])
  )
})

export const zMessages = z.array(
  z.object({
    author_id: z.optional(z.coerce.bigint()),
    content: z.optional(zMessageContent),
    created: z.optional(z.coerce.bigint()),
    direction: z.optional(z.enum(['in', 'out'])),
    id: z.optional(z.string()),
    is_read: z.optional(z.boolean()),
    quote: z.optional(zMessageQuote),
    read: z.optional(z.union([z.int(), z.null()])),
    type: z.optional(
      z.enum(['text', 'image', 'link', 'item', 'location', 'call', 'deleted', 'voice'])
    )
  })
)

export const zVoiceFiles = z.object({
  voices_urls: z.optional(z.record(z.string(), z.url()))
})

export const zWebhookMessage = z.object({
  id: z.optional(z.string()),
  version: z.optional(z.string()),
  timestamp: z.optional(z.int()),
  payload: z.optional(
    z.object({
      type: z.optional(z.string()),
      value: z.optional(
        z.object({
          id: z.optional(z.string()),
          chat_id: z.optional(z.string()),
          user_id: z.optional(z.int()),
          author_id: z.optional(z.int()),
          created: z.optional(z.int()),
          type: z.optional(
            z.enum([
              'text',
              'image',
              'system',
              'item',
              'call',
              'link',
              'location',
              'deleted',
              'appCall',
              'file',
              'video',
              'voice'
            ])
          ),
          chat_type: z.optional(z.enum(['u2i', 'u2u'])),
          content: z.optional(zMessageContent),
          item_id: z.optional(z.int()),
          published_at: z.optional(z.string()),
          read: z.optional(z.union([z.int(), z.null()]))
        })
      )
    })
  )
})

export const zAddBlacklistRequestBody = z.object({
  users: z.optional(
    z.array(
      z.object({
        context: z.optional(
          z.object({
            item_id: z.optional(z.coerce.bigint()),
            reason_id: z.optional(z.unknown())
          })
        ),
        user_id: z.optional(z.coerce.bigint())
      })
    )
  )
})

export const zAuthError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zBadRequestError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zForbiddenError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zNotFoundError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zPurchasingError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zSendImageMessageRequestBody = z.object({
  image_id: z.string()
})

export const zSendMessageRequestBody = z.object({
  message: z.optional(
    z.object({
      text: z.optional(z.string())
    })
  ),
  type: z.optional(z.enum(['text']))
})

export const zServiceError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zServiceUnavailableError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      message: z.string()
    })
  )
})

export const zValidatingError = z.object({
  error: z.optional(
    z.object({
      code: z.int(),
      fields: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
      message: z.string()
    })
  )
})

export const zWebhookSubscribeRequestBody = z.object({
  url: z.string()
})

/**
 * Токен для авторизации
 */
export const zAuthHeader = z.string()

/**
 * Идентификатор чата (клиента)
 */
export const zChatId = z.string()

/**
 * Фильтрация возвращаемых чатов.
 * * u2i — чаты по объявлениям;
 * * u2u — чаты между пользователями;
 *
 */
export const zChatTypes = z.array(z.enum(['u2i', 'u2u'])).default('u2i')

/**
 * Идентификатор загруженного изображения
 */
export const zImageId = z.string()

/**
 * Получение чатов только по объявлениям с указанными item_id
 */
export const zItemIds = z.array(z.coerce.bigint())

/**
 * Количество сообщений / чатов для запроса
 */
export const zLimit = z.int().gte(1).lte(100).default(100)

/**
 * Идентификатор сообщения
 */
export const zMessageId = z.string()

/**
 * Сдвиг сообщений / чатов для запроса
 */
export const zOffset = z.int().default(0)

/**
 * При значении true метод возвращает только непрочитанные чаты
 */
export const zUnreadOnly = z.boolean().default(false)

/**
 * Идентификатор пользователя (клиента)
 */
export const zUserId = z.coerce.bigint()

/**
 * Получение файлов голосовых сообщений с указанными voice_id
 */
export const zVoiceIds = z.array(z.string())

export const zPostSendMessageData = z.object({
  body: z.optional(zSendMessageRequestBody),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zPostSendMessageResponse = z.object({
  content: z.optional(
    z.object({
      text: z.optional(z.string())
    })
  ),
  created: z.optional(z.int()),
  direction: z.optional(z.string()),
  id: z.optional(z.string()),
  type: z.optional(z.string())
})

export const zPostSendImageMessageData = z.object({
  body: z.optional(zSendImageMessageRequestBody),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zPostSendImageMessageResponse = z.object({
  author_id: z.optional(z.int()),
  content: z.optional(
    z.object({
      image: z.optional(
        z.object({
          sizes: z.optional(z.record(z.string(), z.string()))
        })
      )
    })
  ),
  created: z.optional(z.int()),
  direction: z.optional(z.string()),
  id: z.optional(z.string()),
  type: z.optional(z.string())
})

export const zDeleteMessageData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string(),
    message_id: z.string()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zDeleteMessageResponse = z.record(z.string(), z.unknown())

export const zChatReadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zChatReadResponse = z.object({
  ok: z.optional(z.boolean())
})

export const zGetVoiceFilesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint()
  }),
  query: z.object({
    voice_ids: z.array(z.string())
  }),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zGetVoiceFilesResponse = zVoiceFiles

export const zUploadImagesData = z.object({
  body: z.optional(
    z.object({
      'uploadfile[]': z.string()
    })
  ),
  path: z.object({
    user_id: z.coerce.bigint()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zUploadImagesResponse = z.record(z.string(), z.record(z.string(), z.string()))

export const zGetSubscriptionsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zGetSubscriptionsResponse = z.object({
  subscriptions: z.array(
    z.object({
      url: z.string(),
      version: z.string()
    })
  )
})

export const zPostWebhookUnsubscribeData = z.object({
  body: z.optional(zWebhookSubscribeRequestBody),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zPostWebhookUnsubscribeResponse = z.object({
  ok: z.optional(z.boolean())
})

export const zPostBlacklistV2Data = z.object({
  body: z.optional(zAddBlacklistRequestBody),
  path: z.object({
    user_id: z.coerce.bigint()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

export const zGetChatsV2Data = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint()
  }),
  query: z.optional(
    z.object({
      item_ids: z.optional(z.array(z.coerce.bigint())),
      unread_only: z.optional(z.boolean()).default(false),
      chat_types: z.optional(z.array(z.enum(['u2i', 'u2u']))).default('u2i'),
      limit: z.optional(z.int().gte(1).lte(100)).default(100),
      offset: z.optional(z.int()).default(0)
    })
  ),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zGetChatsV2Response = zChats

export const zGetChatByIdV2Data = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string()
  }),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zGetChatByIdV2Response = zChat

export const zGetMessagesV3Data = z.object({
  body: z.optional(z.never()),
  path: z.object({
    user_id: z.coerce.bigint(),
    chat_id: z.string()
  }),
  query: z.optional(
    z.object({
      limit: z.optional(z.int().gte(1).lte(100)).default(100),
      offset: z.optional(z.int()).default(0)
    })
  ),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

/**
 * Успешный ответ
 */
export const zGetMessagesV3Response = zMessages

export const zPostWebhookV3Data = z.object({
  body: z.optional(zWebhookSubscribeRequestBody),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.optional(
    z.object({
      Authorization: z.optional(z.string())
    })
  )
})

export const zPostWebhookV3Response = z.union([
  z.object({
    ok: z.optional(z.boolean())
  }),
  zWebhookMessage
])
