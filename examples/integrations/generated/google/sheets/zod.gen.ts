// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * Represents a color in the RGBA color space. This representation is designed for simplicity of conversion to/from color representations in various languages over compactness. For example, the fields of this representation can be trivially provided to the constructor of `java.awt.Color` in Java; it can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha` method in iOS; and, with just a little work, it can be easily formatted into a CSS `rgba()` string in JavaScript. This reference page doesn't carry information about the absolute color space that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB, DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color space. When color equality needs to be decided, implementations, unless documented otherwise, treat two colors as equal if all their red, green, blue, and alpha values each differ by at most 1e-5. Example (Java): import com.google.type.Color; // ... public static java.awt.Color fromProto(Color protocolor) { float alpha = protocolor.hasAlpha() ? protocolor.getAlpha().getValue() : 1.0; return new java.awt.Color( protocolor.getRed(), protocolor.getGreen(), protocolor.getBlue(), alpha); } public static Color toProto(java.awt.Color color) { float red = (float) color.getRed(); float green = (float) color.getGreen(); float blue = (float) color.getBlue(); float denominator = 255.0; Color.Builder resultBuilder = Color .newBuilder() .setRed(red / denominator) .setGreen(green / denominator) .setBlue(blue / denominator); int alpha = color.getAlpha(); if (alpha != 255) { result.setAlpha( FloatValue .newBuilder() .setValue(((float) alpha) / denominator) .build()); } return resultBuilder.build(); } // ... Example (iOS / Obj-C): // ... static UIColor* fromProto(Color* protocolor) { float red = [protocolor red]; float green = [protocolor green]; float blue = [protocolor blue]; FloatValue* alpha_wrapper = [protocolor alpha]; float alpha = 1.0; if (alpha_wrapper != nil) { alpha = [alpha_wrapper value]; } return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } static Color* toProto(UIColor* color) { CGFloat red, green, blue, alpha; if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) { return nil; } Color* result = [[Color alloc] init]; [result setRed:red]; [result setGreen:green]; [result setBlue:blue]; if (alpha <= 0.9999) { [result setAlpha:floatWrapperWithValue(alpha)]; } [result autorelease]; return result; } // ... Example (JavaScript): // ... var protoToCssColor = function(rgb_color) { var redFrac = rgb_color.red || 0.0; var greenFrac = rgb_color.green || 0.0; var blueFrac = rgb_color.blue || 0.0; var red = Math.floor(redFrac * 255); var green = Math.floor(greenFrac * 255); var blue = Math.floor(blueFrac * 255); if (!('alpha' in rgb_color)) { return rgbToCssColor(red, green, blue); } var alphaFrac = rgb_color.alpha.value || 0.0; var rgbParams = [red, green, blue].join(','); return ['rgba(', rgbParams, ',', alphaFrac, ')'].join(''); }; var rgbToCssColor = function(red, green, blue) { var rgbNumber = new Number((red << 16) | (green << 8) | blue); var hexString = rgbNumber.toString(16); var missingZeros = 6 - hexString.length; var resultBuilder = ['#']; for (var i = 0; i < missingZeros; i++) { resultBuilder.push('0'); } resultBuilder.push(hexString); return resultBuilder.join(''); }; // ...
 */
export const zColor = z.object({
  alpha: z.optional(z.number()),
  blue: z.optional(z.number()),
  green: z.optional(z.number()),
  red: z.optional(z.number())
})

/**
 * A color value.
 */
export const zColorStyle = z.object({
  rgbColor: z.optional(zColor),
  themeColor: z.optional(
    z.enum([
      'THEME_COLOR_TYPE_UNSPECIFIED',
      'TEXT',
      'BACKGROUND',
      'ACCENT1',
      'ACCENT2',
      'ACCENT3',
      'ACCENT4',
      'ACCENT5',
      'ACCENT6',
      'LINK'
    ])
  )
})

/**
 * Properties referring a single dimension (either row or column). If both BandedRange.row_properties and BandedRange.column_properties are set, the fill colors are applied to cells according to the following rules: * header_color and footer_color take priority over band colors. * first_band_color takes priority over second_band_color. * row_properties takes priority over column_properties. For example, the first row color takes priority over the first column color, but the first column color takes priority over the second row color. Similarly, the row header takes priority over the column header in the top left cell, but the column header takes priority over the first row color if the row header is not set.
 */
export const zBandingProperties = z.object({
  firstBandColor: z.optional(zColor),
  firstBandColorStyle: z.optional(zColorStyle),
  footerColor: z.optional(zColor),
  footerColorStyle: z.optional(zColorStyle),
  headerColor: z.optional(zColor),
  headerColorStyle: z.optional(zColorStyle),
  secondBandColor: z.optional(zColor),
  secondBandColorStyle: z.optional(zColorStyle)
})

/**
 * A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `"Sheet1"` is sheet ID 123456, then: `Sheet1!A1:A1 == sheet_id: 123456, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 123456, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 123456, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 123456, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id: 123456` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`.
 */
export const zGridRange = z.object({
  endColumnIndex: z.optional(z.int()),
  endRowIndex: z.optional(z.int()),
  sheetId: z.optional(z.int()),
  startColumnIndex: z.optional(z.int()),
  startRowIndex: z.optional(z.int())
})

/**
 * A banded (alternating colors) range in a sheet.
 */
export const zBandedRange = z.object({
  bandedRangeId: z.optional(z.int()),
  columnProperties: z.optional(zBandingProperties),
  range: z.optional(zGridRange),
  rowProperties: z.optional(zBandingProperties)
})

/**
 * Adds a new banded range to the spreadsheet.
 */
export const zAddBandingRequest = z.object({
  bandedRange: z.optional(zBandedRange)
})

/**
 * The result of adding a banded range.
 */
export const zAddBandingResponse = z.object({
  bandedRange: z.optional(zBandedRange)
})

/**
 * A border along an embedded object.
 */
export const zEmbeddedObjectBorder = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle)
})

/**
 * A coordinate in a sheet. All indexes are zero-based.
 */
export const zGridCoordinate = z.object({
  columnIndex: z.optional(z.int()),
  rowIndex: z.optional(z.int()),
  sheetId: z.optional(z.int())
})

/**
 * The location an object is overlaid on top of a grid.
 */
export const zOverlayPosition = z.object({
  anchorCell: z.optional(zGridCoordinate),
  heightPixels: z.optional(z.int()),
  offsetXPixels: z.optional(z.int()),
  offsetYPixels: z.optional(z.int()),
  widthPixels: z.optional(z.int())
})

/**
 * The position of an embedded object such as a chart.
 */
export const zEmbeddedObjectPosition = z.object({
  newSheet: z.optional(z.boolean()),
  overlayPosition: z.optional(zOverlayPosition),
  sheetId: z.optional(z.int())
})

/**
 * An external or local reference.
 */
export const zLink = z.object({
  uri: z.optional(z.string())
})

/**
 * The format of a run of text in a cell. Absent values indicate that the field isn't specified.
 */
export const zTextFormat = z.object({
  bold: z.optional(z.boolean()),
  fontFamily: z.optional(z.string()),
  fontSize: z.optional(z.int()),
  foregroundColor: z.optional(zColor),
  foregroundColorStyle: z.optional(zColorStyle),
  italic: z.optional(z.boolean()),
  link: z.optional(zLink),
  strikethrough: z.optional(z.boolean()),
  underline: z.optional(z.boolean())
})

/**
 * Position settings for text.
 */
export const zTextPosition = z.object({
  horizontalAlignment: z.optional(
    z.enum(['HORIZONTAL_ALIGN_UNSPECIFIED', 'LEFT', 'CENTER', 'RIGHT'])
  )
})

/**
 * The options that define a "view window" for a chart (such as the visible values in an axis).
 */
export const zChartAxisViewWindowOptions = z.object({
  viewWindowMax: z.optional(z.number()),
  viewWindowMin: z.optional(z.number()),
  viewWindowMode: z.optional(
    z.enum(['DEFAULT_VIEW_WINDOW_MODE', 'VIEW_WINDOW_MODE_UNSUPPORTED', 'EXPLICIT', 'PRETTY'])
  )
})

/**
 * An axis of the chart. A chart may not have more than one axis per axis position.
 */
export const zBasicChartAxis = z.object({
  format: z.optional(zTextFormat),
  position: z.optional(
    z.enum(['BASIC_CHART_AXIS_POSITION_UNSPECIFIED', 'BOTTOM_AXIS', 'LEFT_AXIS', 'RIGHT_AXIS'])
  ),
  title: z.optional(z.string()),
  titleTextPosition: z.optional(zTextPosition),
  viewWindowOptions: z.optional(zChartAxisViewWindowOptions)
})

/**
 * An unique identifier that references a data source column.
 */
export const zDataSourceColumnReference = z.object({
  name: z.optional(z.string())
})

/**
 * Allows you to organize the date-time values in a source data column into buckets based on selected parts of their date or time values.
 */
export const zChartDateTimeRule = z.object({
  type: z.optional(
    z.enum([
      'CHART_DATE_TIME_RULE_TYPE_UNSPECIFIED',
      'SECOND',
      'MINUTE',
      'HOUR',
      'HOUR_MINUTE',
      'HOUR_MINUTE_AMPM',
      'DAY_OF_WEEK',
      'DAY_OF_YEAR',
      'DAY_OF_MONTH',
      'DAY_MONTH',
      'MONTH',
      'QUARTER',
      'YEAR',
      'YEAR_MONTH',
      'YEAR_QUARTER',
      'YEAR_MONTH_DAY'
    ])
  )
})

/**
 * Allows you to organize numeric values in a source data column into buckets of constant size.
 */
export const zChartHistogramRule = z.object({
  intervalSize: z.optional(z.number()),
  maxValue: z.optional(z.number()),
  minValue: z.optional(z.number())
})

/**
 * An optional setting on the ChartData of the domain of a data source chart that defines buckets for the values in the domain rather than breaking out each individual value. For example, when plotting a data source chart, you can specify a histogram rule on the domain (it should only contain numeric values), grouping its values into buckets. Any values of a chart series that fall into the same bucket are aggregated based on the aggregate_type.
 */
export const zChartGroupRule = z.object({
  dateTimeRule: z.optional(zChartDateTimeRule),
  histogramRule: z.optional(zChartHistogramRule)
})

/**
 * Source ranges for a chart.
 */
export const zChartSourceRange = z.object({
  sources: z.optional(z.array(zGridRange))
})

/**
 * The data included in a domain or series.
 */
export const zChartData = z.object({
  aggregateType: z.optional(
    z.enum(['CHART_AGGREGATE_TYPE_UNSPECIFIED', 'AVERAGE', 'COUNT', 'MAX', 'MEDIAN', 'MIN', 'SUM'])
  ),
  columnReference: z.optional(zDataSourceColumnReference),
  groupRule: z.optional(zChartGroupRule),
  sourceRange: z.optional(zChartSourceRange)
})

/**
 * The domain of a chart. For example, if charting stock prices over time, this would be the date.
 */
export const zBasicChartDomain = z.object({
  domain: z.optional(zChartData),
  reversed: z.optional(z.boolean())
})

/**
 * Settings for one set of data labels. Data labels are annotations that appear next to a set of data, such as the points on a line chart, and provide additional information about what the data represents, such as a text representation of the value behind that point on the graph.
 */
export const zDataLabel = z.object({
  customLabelData: z.optional(zChartData),
  placement: z.optional(
    z.enum([
      'DATA_LABEL_PLACEMENT_UNSPECIFIED',
      'CENTER',
      'LEFT',
      'RIGHT',
      'ABOVE',
      'BELOW',
      'INSIDE_END',
      'INSIDE_BASE',
      'OUTSIDE_END'
    ])
  ),
  textFormat: z.optional(zTextFormat),
  type: z.optional(z.enum(['DATA_LABEL_TYPE_UNSPECIFIED', 'NONE', 'DATA', 'CUSTOM']))
})

/**
 * Properties that describe the style of a line.
 */
export const zLineStyle = z.object({
  type: z.optional(
    z.enum([
      'LINE_DASH_TYPE_UNSPECIFIED',
      'INVISIBLE',
      'CUSTOM',
      'SOLID',
      'DOTTED',
      'MEDIUM_DASHED',
      'MEDIUM_DASHED_DOTTED',
      'LONG_DASHED',
      'LONG_DASHED_DOTTED'
    ])
  ),
  width: z.optional(z.int())
})

/**
 * The style of a point on the chart.
 */
export const zPointStyle = z.object({
  shape: z.optional(
    z.enum([
      'POINT_SHAPE_UNSPECIFIED',
      'CIRCLE',
      'DIAMOND',
      'HEXAGON',
      'PENTAGON',
      'SQUARE',
      'STAR',
      'TRIANGLE',
      'X_MARK'
    ])
  ),
  size: z.optional(z.number())
})

/**
 * Style override settings for a single series data point.
 */
export const zBasicSeriesDataPointStyleOverride = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle),
  index: z.optional(z.int()),
  pointStyle: z.optional(zPointStyle)
})

/**
 * A single series of data in a chart. For example, if charting stock prices over time, multiple series may exist, one for the "Open Price", "High Price", "Low Price" and "Close Price".
 */
export const zBasicChartSeries = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle),
  dataLabel: z.optional(zDataLabel),
  lineStyle: z.optional(zLineStyle),
  pointStyle: z.optional(zPointStyle),
  series: z.optional(zChartData),
  styleOverrides: z.optional(z.array(zBasicSeriesDataPointStyleOverride)),
  targetAxis: z.optional(
    z.enum(['BASIC_CHART_AXIS_POSITION_UNSPECIFIED', 'BOTTOM_AXIS', 'LEFT_AXIS', 'RIGHT_AXIS'])
  ),
  type: z.optional(
    z.enum([
      'BASIC_CHART_TYPE_UNSPECIFIED',
      'BAR',
      'LINE',
      'AREA',
      'COLUMN',
      'SCATTER',
      'COMBO',
      'STEPPED_AREA'
    ])
  )
})

/**
 * The specification for a basic chart. See BasicChartType for the list of charts this supports.
 */
export const zBasicChartSpec = z.object({
  axis: z.optional(z.array(zBasicChartAxis)),
  chartType: z.optional(
    z.enum([
      'BASIC_CHART_TYPE_UNSPECIFIED',
      'BAR',
      'LINE',
      'AREA',
      'COLUMN',
      'SCATTER',
      'COMBO',
      'STEPPED_AREA'
    ])
  ),
  compareMode: z.optional(z.enum(['BASIC_CHART_COMPARE_MODE_UNSPECIFIED', 'DATUM', 'CATEGORY'])),
  domains: z.optional(z.array(zBasicChartDomain)),
  headerCount: z.optional(z.int()),
  interpolateNulls: z.optional(z.boolean()),
  legendPosition: z.optional(
    z.enum([
      'BASIC_CHART_LEGEND_POSITION_UNSPECIFIED',
      'BOTTOM_LEGEND',
      'LEFT_LEGEND',
      'RIGHT_LEGEND',
      'TOP_LEGEND',
      'NO_LEGEND'
    ])
  ),
  lineSmoothing: z.optional(z.boolean()),
  series: z.optional(z.array(zBasicChartSeries)),
  stackedType: z.optional(
    z.enum(['BASIC_CHART_STACKED_TYPE_UNSPECIFIED', 'NOT_STACKED', 'STACKED', 'PERCENT_STACKED'])
  ),
  threeDimensional: z.optional(z.boolean()),
  totalDataLabel: z.optional(zDataLabel)
})

/**
 * A bubble chart.
 */
export const zBubbleChartSpec = z.object({
  bubbleBorderColor: z.optional(zColor),
  bubbleBorderColorStyle: z.optional(zColorStyle),
  bubbleLabels: z.optional(zChartData),
  bubbleMaxRadiusSize: z.optional(z.int()),
  bubbleMinRadiusSize: z.optional(z.int()),
  bubbleOpacity: z.optional(z.number()),
  bubbleSizes: z.optional(zChartData),
  bubbleTextStyle: z.optional(zTextFormat),
  domain: z.optional(zChartData),
  groupIds: z.optional(zChartData),
  legendPosition: z.optional(
    z.enum([
      'BUBBLE_CHART_LEGEND_POSITION_UNSPECIFIED',
      'BOTTOM_LEGEND',
      'LEFT_LEGEND',
      'RIGHT_LEGEND',
      'TOP_LEGEND',
      'NO_LEGEND',
      'INSIDE_LEGEND'
    ])
  ),
  series: z.optional(zChartData)
})

/**
 * The series of a CandlestickData.
 */
export const zCandlestickSeries = z.object({
  data: z.optional(zChartData)
})

/**
 * The Candlestick chart data, each containing the low, open, close, and high values for a series.
 */
export const zCandlestickData = z.object({
  closeSeries: z.optional(zCandlestickSeries),
  highSeries: z.optional(zCandlestickSeries),
  lowSeries: z.optional(zCandlestickSeries),
  openSeries: z.optional(zCandlestickSeries)
})

/**
 * The domain of a CandlestickChart.
 */
export const zCandlestickDomain = z.object({
  data: z.optional(zChartData),
  reversed: z.optional(z.boolean())
})

/**
 * A candlestick chart.
 */
export const zCandlestickChartSpec = z.object({
  data: z.optional(z.array(zCandlestickData)),
  domain: z.optional(zCandlestickDomain)
})

/**
 * The data execution status. A data execution is created to sync a data source object with the latest data from a DataSource. It is usually scheduled to run at background, you can check its state to tell if an execution completes There are several scenarios where a data execution is triggered to run: * Adding a data source creates an associated data source sheet as well as a data execution to sync the data from the data source to the sheet. * Updating a data source creates a data execution to refresh the associated data source sheet similarly. * You can send refresh request to explicitly refresh one or multiple data source objects.
 */
export const zDataExecutionStatus = z.object({
  errorCode: z.optional(
    z.enum([
      'DATA_EXECUTION_ERROR_CODE_UNSPECIFIED',
      'TIMED_OUT',
      'TOO_MANY_ROWS',
      'TOO_MANY_COLUMNS',
      'TOO_MANY_CELLS',
      'ENGINE',
      'PARAMETER_INVALID',
      'UNSUPPORTED_DATA_TYPE',
      'DUPLICATE_COLUMN_NAMES',
      'INTERRUPTED',
      'CONCURRENT_QUERY',
      'OTHER',
      'TOO_MANY_CHARS_PER_CELL',
      'DATA_NOT_FOUND',
      'PERMISSION_DENIED',
      'MISSING_COLUMN_ALIAS',
      'OBJECT_NOT_FOUND',
      'OBJECT_IN_ERROR_STATE',
      'OBJECT_SPEC_INVALID'
    ])
  ),
  errorMessage: z.optional(z.string()),
  lastRefreshTime: z.optional(z.string()),
  state: z.optional(
    z.enum(['DATA_EXECUTION_STATE_UNSPECIFIED', 'NOT_STARTED', 'RUNNING', 'SUCCEEDED', 'FAILED'])
  )
})

/**
 * Properties of a data source chart.
 */
export const zDataSourceChartProperties = z.object({
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSourceId: z.optional(z.string())
})

/**
 * The value of the condition.
 */
export const zConditionValue = z.object({
  relativeDate: z.optional(
    z.enum([
      'RELATIVE_DATE_UNSPECIFIED',
      'PAST_YEAR',
      'PAST_MONTH',
      'PAST_WEEK',
      'YESTERDAY',
      'TODAY',
      'TOMORROW'
    ])
  ),
  userEnteredValue: z.optional(z.string())
})

/**
 * A condition that can evaluate to true or false. BooleanConditions are used by conditional formatting, data validation, and the criteria in filters.
 */
export const zBooleanCondition = z.object({
  type: z.optional(
    z.enum([
      'CONDITION_TYPE_UNSPECIFIED',
      'NUMBER_GREATER',
      'NUMBER_GREATER_THAN_EQ',
      'NUMBER_LESS',
      'NUMBER_LESS_THAN_EQ',
      'NUMBER_EQ',
      'NUMBER_NOT_EQ',
      'NUMBER_BETWEEN',
      'NUMBER_NOT_BETWEEN',
      'TEXT_CONTAINS',
      'TEXT_NOT_CONTAINS',
      'TEXT_STARTS_WITH',
      'TEXT_ENDS_WITH',
      'TEXT_EQ',
      'TEXT_IS_EMAIL',
      'TEXT_IS_URL',
      'DATE_EQ',
      'DATE_BEFORE',
      'DATE_AFTER',
      'DATE_ON_OR_BEFORE',
      'DATE_ON_OR_AFTER',
      'DATE_BETWEEN',
      'DATE_NOT_BETWEEN',
      'DATE_IS_VALID',
      'ONE_OF_RANGE',
      'ONE_OF_LIST',
      'BLANK',
      'NOT_BLANK',
      'CUSTOM_FORMULA',
      'BOOLEAN',
      'TEXT_NOT_EQ',
      'DATE_NOT_EQ'
    ])
  ),
  values: z.optional(z.array(zConditionValue))
})

/**
 * Criteria for showing/hiding rows in a filter or filter view.
 */
export const zFilterCriteria = z.object({
  condition: z.optional(zBooleanCondition),
  hiddenValues: z.optional(z.array(z.string())),
  visibleBackgroundColor: z.optional(zColor),
  visibleBackgroundColorStyle: z.optional(zColorStyle),
  visibleForegroundColor: z.optional(zColor),
  visibleForegroundColorStyle: z.optional(zColorStyle)
})

/**
 * The filter criteria associated with a specific column.
 */
export const zFilterSpec = z.object({
  columnIndex: z.optional(z.int()),
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  filterCriteria: z.optional(zFilterCriteria)
})

/**
 * A histogram series containing the series color and data.
 */
export const zHistogramSeries = z.object({
  barColor: z.optional(zColor),
  barColorStyle: z.optional(zColorStyle),
  data: z.optional(zChartData)
})

/**
 * A histogram chart. A histogram chart groups data items into bins, displaying each bin as a column of stacked items. Histograms are used to display the distribution of a dataset. Each column of items represents a range into which those items fall. The number of bins can be chosen automatically or specified explicitly.
 */
export const zHistogramChartSpec = z.object({
  bucketSize: z.optional(z.number()),
  legendPosition: z.optional(
    z.enum([
      'HISTOGRAM_CHART_LEGEND_POSITION_UNSPECIFIED',
      'BOTTOM_LEGEND',
      'LEFT_LEGEND',
      'RIGHT_LEGEND',
      'TOP_LEGEND',
      'NO_LEGEND',
      'INSIDE_LEGEND'
    ])
  ),
  outlierPercentile: z.optional(z.number()),
  series: z.optional(z.array(zHistogramSeries)),
  showItemDividers: z.optional(z.boolean())
})

/**
 * An org chart. Org charts require a unique set of labels in labels and may optionally include parent_labels and tooltips. parent_labels contain, for each node, the label identifying the parent node. tooltips contain, for each node, an optional tooltip. For example, to describe an OrgChart with Alice as the CEO, Bob as the President (reporting to Alice) and Cathy as VP of Sales (also reporting to Alice), have labels contain "Alice", "Bob", "Cathy", parent_labels contain "", "Alice", "Alice" and tooltips contain "CEO", "President", "VP Sales".
 */
export const zOrgChartSpec = z.object({
  labels: z.optional(zChartData),
  nodeColor: z.optional(zColor),
  nodeColorStyle: z.optional(zColorStyle),
  nodeSize: z.optional(z.enum(['ORG_CHART_LABEL_SIZE_UNSPECIFIED', 'SMALL', 'MEDIUM', 'LARGE'])),
  parentLabels: z.optional(zChartData),
  selectedNodeColor: z.optional(zColor),
  selectedNodeColorStyle: z.optional(zColorStyle),
  tooltips: z.optional(zChartData)
})

/**
 * A pie chart.
 */
export const zPieChartSpec = z.object({
  domain: z.optional(zChartData),
  legendPosition: z.optional(
    z.enum([
      'PIE_CHART_LEGEND_POSITION_UNSPECIFIED',
      'BOTTOM_LEGEND',
      'LEFT_LEGEND',
      'RIGHT_LEGEND',
      'TOP_LEGEND',
      'NO_LEGEND',
      'LABELED_LEGEND'
    ])
  ),
  pieHole: z.optional(z.number()),
  series: z.optional(zChartData),
  threeDimensional: z.optional(z.boolean())
})

/**
 * Formatting options for baseline value.
 */
export const zBaselineValueFormat = z.object({
  comparisonType: z.optional(
    z.enum(['COMPARISON_TYPE_UNDEFINED', 'ABSOLUTE_DIFFERENCE', 'PERCENTAGE_DIFFERENCE'])
  ),
  description: z.optional(z.string()),
  negativeColor: z.optional(zColor),
  negativeColorStyle: z.optional(zColorStyle),
  position: z.optional(zTextPosition),
  positiveColor: z.optional(zColor),
  positiveColorStyle: z.optional(zColorStyle),
  textFormat: z.optional(zTextFormat)
})

/**
 * Custom number formatting options for chart attributes.
 */
export const zChartCustomNumberFormatOptions = z.object({
  prefix: z.optional(z.string()),
  suffix: z.optional(z.string())
})

/**
 * Formatting options for key value.
 */
export const zKeyValueFormat = z.object({
  position: z.optional(zTextPosition),
  textFormat: z.optional(zTextFormat)
})

/**
 * A scorecard chart. Scorecard charts are used to highlight key performance indicators, known as KPIs, on the spreadsheet. A scorecard chart can represent things like total sales, average cost, or a top selling item. You can specify a single data value, or aggregate over a range of data. Percentage or absolute difference from a baseline value can be highlighted, like changes over time.
 */
export const zScorecardChartSpec = z.object({
  aggregateType: z.optional(
    z.enum(['CHART_AGGREGATE_TYPE_UNSPECIFIED', 'AVERAGE', 'COUNT', 'MAX', 'MEDIAN', 'MIN', 'SUM'])
  ),
  baselineValueData: z.optional(zChartData),
  baselineValueFormat: z.optional(zBaselineValueFormat),
  customFormatOptions: z.optional(zChartCustomNumberFormatOptions),
  keyValueData: z.optional(zChartData),
  keyValueFormat: z.optional(zKeyValueFormat),
  numberFormatSource: z.optional(
    z.enum(['CHART_NUMBER_FORMAT_SOURCE_UNDEFINED', 'FROM_DATA', 'CUSTOM'])
  ),
  scaleFactor: z.optional(z.number())
})

/**
 * A sort order associated with a specific column or row.
 */
export const zSortSpec = z.object({
  backgroundColor: z.optional(zColor),
  backgroundColorStyle: z.optional(zColorStyle),
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  dimensionIndex: z.optional(z.int()),
  foregroundColor: z.optional(zColor),
  foregroundColorStyle: z.optional(zColorStyle),
  sortOrder: z.optional(z.enum(['SORT_ORDER_UNSPECIFIED', 'ASCENDING', 'DESCENDING']))
})

/**
 * A color scale for a treemap chart.
 */
export const zTreemapChartColorScale = z.object({
  maxValueColor: z.optional(zColor),
  maxValueColorStyle: z.optional(zColorStyle),
  midValueColor: z.optional(zColor),
  midValueColorStyle: z.optional(zColorStyle),
  minValueColor: z.optional(zColor),
  minValueColorStyle: z.optional(zColorStyle),
  noDataColor: z.optional(zColor),
  noDataColorStyle: z.optional(zColorStyle)
})

/**
 * A Treemap chart.
 */
export const zTreemapChartSpec = z.object({
  colorData: z.optional(zChartData),
  colorScale: z.optional(zTreemapChartColorScale),
  headerColor: z.optional(zColor),
  headerColorStyle: z.optional(zColorStyle),
  hideTooltips: z.optional(z.boolean()),
  hintedLevels: z.optional(z.int()),
  labels: z.optional(zChartData),
  levels: z.optional(z.int()),
  maxValue: z.optional(z.number()),
  minValue: z.optional(z.number()),
  parentLabels: z.optional(zChartData),
  sizeData: z.optional(zChartData),
  textFormat: z.optional(zTextFormat)
})

/**
 * The domain of a waterfall chart.
 */
export const zWaterfallChartDomain = z.object({
  data: z.optional(zChartData),
  reversed: z.optional(z.boolean())
})

/**
 * A custom subtotal column for a waterfall chart series.
 */
export const zWaterfallChartCustomSubtotal = z.object({
  dataIsSubtotal: z.optional(z.boolean()),
  label: z.optional(z.string()),
  subtotalIndex: z.optional(z.int())
})

/**
 * Styles for a waterfall chart column.
 */
export const zWaterfallChartColumnStyle = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle),
  label: z.optional(z.string())
})

/**
 * A single series of data for a waterfall chart.
 */
export const zWaterfallChartSeries = z.object({
  customSubtotals: z.optional(z.array(zWaterfallChartCustomSubtotal)),
  data: z.optional(zChartData),
  dataLabel: z.optional(zDataLabel),
  hideTrailingSubtotal: z.optional(z.boolean()),
  negativeColumnsStyle: z.optional(zWaterfallChartColumnStyle),
  positiveColumnsStyle: z.optional(zWaterfallChartColumnStyle),
  subtotalColumnsStyle: z.optional(zWaterfallChartColumnStyle)
})

/**
 * A waterfall chart.
 */
export const zWaterfallChartSpec = z.object({
  connectorLineStyle: z.optional(zLineStyle),
  domain: z.optional(zWaterfallChartDomain),
  firstValueIsTotal: z.optional(z.boolean()),
  hideConnectorLines: z.optional(z.boolean()),
  series: z.optional(z.array(zWaterfallChartSeries)),
  stackedType: z.optional(z.enum(['WATERFALL_STACKED_TYPE_UNSPECIFIED', 'STACKED', 'SEQUENTIAL'])),
  totalDataLabel: z.optional(zDataLabel)
})

/**
 * The specifications of a chart.
 */
export const zChartSpec = z.object({
  altText: z.optional(z.string()),
  backgroundColor: z.optional(zColor),
  backgroundColorStyle: z.optional(zColorStyle),
  basicChart: z.optional(zBasicChartSpec),
  bubbleChart: z.optional(zBubbleChartSpec),
  candlestickChart: z.optional(zCandlestickChartSpec),
  dataSourceChartProperties: z.optional(zDataSourceChartProperties),
  filterSpecs: z.optional(z.array(zFilterSpec)),
  fontName: z.optional(z.string()),
  hiddenDimensionStrategy: z.optional(
    z.enum([
      'CHART_HIDDEN_DIMENSION_STRATEGY_UNSPECIFIED',
      'SKIP_HIDDEN_ROWS_AND_COLUMNS',
      'SKIP_HIDDEN_ROWS',
      'SKIP_HIDDEN_COLUMNS',
      'SHOW_ALL'
    ])
  ),
  histogramChart: z.optional(zHistogramChartSpec),
  maximized: z.optional(z.boolean()),
  orgChart: z.optional(zOrgChartSpec),
  pieChart: z.optional(zPieChartSpec),
  scorecardChart: z.optional(zScorecardChartSpec),
  sortSpecs: z.optional(z.array(zSortSpec)),
  subtitle: z.optional(z.string()),
  subtitleTextFormat: z.optional(zTextFormat),
  subtitleTextPosition: z.optional(zTextPosition),
  title: z.optional(z.string()),
  titleTextFormat: z.optional(zTextFormat),
  titleTextPosition: z.optional(zTextPosition),
  treemapChart: z.optional(zTreemapChartSpec),
  waterfallChart: z.optional(zWaterfallChartSpec)
})

/**
 * A chart embedded in a sheet.
 */
export const zEmbeddedChart = z.object({
  border: z.optional(zEmbeddedObjectBorder),
  chartId: z.optional(z.int()),
  position: z.optional(zEmbeddedObjectPosition),
  spec: z.optional(zChartSpec)
})

/**
 * Adds a chart to a sheet in the spreadsheet.
 */
export const zAddChartRequest = z.object({
  chart: z.optional(zEmbeddedChart)
})

/**
 * The result of adding a chart to a spreadsheet.
 */
export const zAddChartResponse = z.object({
  chart: z.optional(zEmbeddedChart)
})

/**
 * A border along a cell.
 */
export const zBorder = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle),
  style: z.optional(
    z.enum([
      'STYLE_UNSPECIFIED',
      'DOTTED',
      'DASHED',
      'SOLID',
      'SOLID_MEDIUM',
      'SOLID_THICK',
      'NONE',
      'DOUBLE'
    ])
  ),
  width: z.optional(z.int())
})

/**
 * The borders of the cell.
 */
export const zBorders = z.object({
  bottom: z.optional(zBorder),
  left: z.optional(zBorder),
  right: z.optional(zBorder),
  top: z.optional(zBorder)
})

/**
 * The number format of a cell.
 */
export const zNumberFormat = z.object({
  pattern: z.optional(z.string()),
  type: z.optional(
    z.enum([
      'NUMBER_FORMAT_TYPE_UNSPECIFIED',
      'TEXT',
      'NUMBER',
      'PERCENT',
      'CURRENCY',
      'DATE',
      'TIME',
      'DATE_TIME',
      'SCIENTIFIC'
    ])
  )
})

/**
 * The amount of padding around the cell, in pixels. When updating padding, every field must be specified.
 */
export const zPadding = z.object({
  bottom: z.optional(z.int()),
  left: z.optional(z.int()),
  right: z.optional(z.int()),
  top: z.optional(z.int())
})

/**
 * The rotation applied to text in a cell.
 */
export const zTextRotation = z.object({
  angle: z.optional(z.int()),
  vertical: z.optional(z.boolean())
})

/**
 * The format of a cell.
 */
export const zCellFormat = z.object({
  backgroundColor: z.optional(zColor),
  backgroundColorStyle: z.optional(zColorStyle),
  borders: z.optional(zBorders),
  horizontalAlignment: z.optional(
    z.enum(['HORIZONTAL_ALIGN_UNSPECIFIED', 'LEFT', 'CENTER', 'RIGHT'])
  ),
  hyperlinkDisplayType: z.optional(
    z.enum(['HYPERLINK_DISPLAY_TYPE_UNSPECIFIED', 'LINKED', 'PLAIN_TEXT'])
  ),
  numberFormat: z.optional(zNumberFormat),
  padding: z.optional(zPadding),
  textDirection: z.optional(
    z.enum(['TEXT_DIRECTION_UNSPECIFIED', 'LEFT_TO_RIGHT', 'RIGHT_TO_LEFT'])
  ),
  textFormat: z.optional(zTextFormat),
  textRotation: z.optional(zTextRotation),
  verticalAlignment: z.optional(z.enum(['VERTICAL_ALIGN_UNSPECIFIED', 'TOP', 'MIDDLE', 'BOTTOM'])),
  wrapStrategy: z.optional(
    z.enum(['WRAP_STRATEGY_UNSPECIFIED', 'OVERFLOW_CELL', 'LEGACY_WRAP', 'CLIP', 'WRAP'])
  )
})

/**
 * A rule that may or may not match, depending on the condition.
 */
export const zBooleanRule = z.object({
  condition: z.optional(zBooleanCondition),
  format: z.optional(zCellFormat)
})

/**
 * A single interpolation point on a gradient conditional format. These pin the gradient color scale according to the color, type and value chosen.
 */
export const zInterpolationPoint = z.object({
  color: z.optional(zColor),
  colorStyle: z.optional(zColorStyle),
  type: z.optional(
    z.enum([
      'INTERPOLATION_POINT_TYPE_UNSPECIFIED',
      'MIN',
      'MAX',
      'NUMBER',
      'PERCENT',
      'PERCENTILE'
    ])
  ),
  value: z.optional(z.string())
})

/**
 * A rule that applies a gradient color scale format, based on the interpolation points listed. The format of a cell will vary based on its contents as compared to the values of the interpolation points.
 */
export const zGradientRule = z.object({
  maxpoint: z.optional(zInterpolationPoint),
  midpoint: z.optional(zInterpolationPoint),
  minpoint: z.optional(zInterpolationPoint)
})

/**
 * A rule describing a conditional format.
 */
export const zConditionalFormatRule = z.object({
  booleanRule: z.optional(zBooleanRule),
  gradientRule: z.optional(zGradientRule),
  ranges: z.optional(z.array(zGridRange))
})

/**
 * Adds a new conditional format rule at the given index. All subsequent rules' indexes are incremented.
 */
export const zAddConditionalFormatRuleRequest = z.object({
  index: z.optional(z.int()),
  rule: z.optional(zConditionalFormatRule)
})

/**
 * A column in a data source.
 */
export const zDataSourceColumn = z.object({
  formula: z.optional(z.string()),
  reference: z.optional(zDataSourceColumnReference)
})

/**
 * Specifies a custom BigQuery query.
 */
export const zBigQueryQuerySpec = z.object({
  rawQuery: z.optional(z.string())
})

/**
 * Specifies a BigQuery table definition. Only [native tables](https://cloud.google.com/bigquery/docs/tables-intro) is allowed.
 */
export const zBigQueryTableSpec = z.object({
  datasetId: z.optional(z.string()),
  tableId: z.optional(z.string()),
  tableProjectId: z.optional(z.string())
})

/**
 * The specification of a BigQuery data source that's connected to a sheet.
 */
export const zBigQueryDataSourceSpec = z.object({
  projectId: z.optional(z.string()),
  querySpec: z.optional(zBigQueryQuerySpec),
  tableSpec: z.optional(zBigQueryTableSpec)
})

/**
 * A parameter in a data source's query. The parameter allows the user to pass in values from the spreadsheet into a query.
 */
export const zDataSourceParameter = z.object({
  name: z.optional(z.string()),
  namedRangeId: z.optional(z.string()),
  range: z.optional(zGridRange)
})

/**
 * This specifies the details of the data source. For example, for BigQuery, this specifies information about the BigQuery source.
 */
export const zDataSourceSpec = z.object({
  bigQuery: z.optional(zBigQueryDataSourceSpec),
  parameters: z.optional(z.array(zDataSourceParameter))
})

/**
 * Information about an external data source in the spreadsheet.
 */
export const zDataSource = z.object({
  calculatedColumns: z.optional(z.array(zDataSourceColumn)),
  dataSourceId: z.optional(z.string()),
  sheetId: z.optional(z.int()),
  spec: z.optional(zDataSourceSpec)
})

/**
 * Adds a data source. After the data source is added successfully, an associated DATA_SOURCE sheet is created and an execution is triggered to refresh the sheet to read data from the data source. The request requires an additional `bigquery.readonly` OAuth scope.
 */
export const zAddDataSourceRequest = z.object({
  dataSource: z.optional(zDataSource)
})

/**
 * The result of adding a data source.
 */
export const zAddDataSourceResponse = z.object({
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSource: z.optional(zDataSource)
})

/**
 * A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side.
 */
export const zDimensionRange = z.object({
  dimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  endIndex: z.optional(z.int()),
  sheetId: z.optional(z.int()),
  startIndex: z.optional(z.int())
})

/**
 * Creates a group over the specified range. If the requested range is a superset of the range of an existing group G, then the depth of G is incremented and this new group G' has the depth of that group. For example, a group [C:D, depth 1] + [B:E] results in groups [B:E, depth 1] and [C:D, depth 2]. If the requested range is a subset of the range of an existing group G, then the depth of the new group G' becomes one greater than the depth of G. For example, a group [B:E, depth 1] + [C:D] results in groups [B:E, depth 1] and [C:D, depth 2]. If the requested range starts before and ends within, or starts within and ends after, the range of an existing group G, then the range of the existing group G becomes the union of the ranges, and the new group G' has depth one greater than the depth of G and range as the intersection of the ranges. For example, a group [B:D, depth 1] + [C:E] results in groups [B:E, depth 1] and [C:D, depth 2].
 */
export const zAddDimensionGroupRequest = z.object({
  range: z.optional(zDimensionRange)
})

/**
 * A group over an interval of rows or columns on a sheet, which can contain or be contained within other groups. A group can be collapsed or expanded as a unit on the sheet.
 */
export const zDimensionGroup = z.object({
  collapsed: z.optional(z.boolean()),
  depth: z.optional(z.int()),
  range: z.optional(zDimensionRange)
})

/**
 * The result of adding a group.
 */
export const zAddDimensionGroupResponse = z.object({
  dimensionGroups: z.optional(z.array(zDimensionGroup))
})

/**
 * A filter view.
 */
export const zFilterView = z.object({
  criteria: z.optional(z.record(z.string(), zFilterCriteria)),
  filterSpecs: z.optional(z.array(zFilterSpec)),
  filterViewId: z.optional(z.int()),
  namedRangeId: z.optional(z.string()),
  range: z.optional(zGridRange),
  sortSpecs: z.optional(z.array(zSortSpec)),
  title: z.optional(z.string())
})

/**
 * Adds a filter view.
 */
export const zAddFilterViewRequest = z.object({
  filter: z.optional(zFilterView)
})

/**
 * The result of adding a filter view.
 */
export const zAddFilterViewResponse = z.object({
  filter: z.optional(zFilterView)
})

/**
 * A named range.
 */
export const zNamedRange = z.object({
  name: z.optional(z.string()),
  namedRangeId: z.optional(z.string()),
  range: z.optional(zGridRange)
})

/**
 * Adds a named range to the spreadsheet.
 */
export const zAddNamedRangeRequest = z.object({
  namedRange: z.optional(zNamedRange)
})

/**
 * The result of adding a named range.
 */
export const zAddNamedRangeResponse = z.object({
  namedRange: z.optional(zNamedRange)
})

/**
 * The editors of a protected range.
 */
export const zEditors = z.object({
  domainUsersCanEdit: z.optional(z.boolean()),
  groups: z.optional(z.array(z.string())),
  users: z.optional(z.array(z.string()))
})

/**
 * A protected range.
 */
export const zProtectedRange = z.object({
  description: z.optional(z.string()),
  editors: z.optional(zEditors),
  namedRangeId: z.optional(z.string()),
  protectedRangeId: z.optional(z.int()),
  range: z.optional(zGridRange),
  requestingUserCanEdit: z.optional(z.boolean()),
  unprotectedRanges: z.optional(z.array(zGridRange)),
  warningOnly: z.optional(z.boolean())
})

/**
 * Adds a new protected range.
 */
export const zAddProtectedRangeRequest = z.object({
  protectedRange: z.optional(zProtectedRange)
})

/**
 * The result of adding a new protected range.
 */
export const zAddProtectedRangeResponse = z.object({
  protectedRange: z.optional(zProtectedRange)
})

/**
 * Additional properties of a DATA_SOURCE sheet.
 */
export const zDataSourceSheetProperties = z.object({
  columns: z.optional(z.array(zDataSourceColumn)),
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSourceId: z.optional(z.string())
})

/**
 * Properties of a grid.
 */
export const zGridProperties = z.object({
  columnCount: z.optional(z.int()),
  columnGroupControlAfter: z.optional(z.boolean()),
  frozenColumnCount: z.optional(z.int()),
  frozenRowCount: z.optional(z.int()),
  hideGridlines: z.optional(z.boolean()),
  rowCount: z.optional(z.int()),
  rowGroupControlAfter: z.optional(z.boolean())
})

/**
 * Properties of a sheet.
 */
export const zSheetProperties = z.object({
  dataSourceSheetProperties: z.optional(zDataSourceSheetProperties),
  gridProperties: z.optional(zGridProperties),
  hidden: z.optional(z.boolean()),
  index: z.optional(z.int()),
  rightToLeft: z.optional(z.boolean()),
  sheetId: z.optional(z.int()),
  sheetType: z.optional(z.enum(['SHEET_TYPE_UNSPECIFIED', 'GRID', 'OBJECT', 'DATA_SOURCE'])),
  tabColor: z.optional(zColor),
  tabColorStyle: z.optional(zColorStyle),
  title: z.optional(z.string())
})

/**
 * Adds a new sheet. When a sheet is added at a given index, all subsequent sheets' indexes are incremented. To add an object sheet, use AddChartRequest instead and specify EmbeddedObjectPosition.sheetId or EmbeddedObjectPosition.newSheet.
 */
export const zAddSheetRequest = z.object({
  properties: z.optional(zSheetProperties)
})

/**
 * The result of adding a sheet.
 */
export const zAddSheetResponse = z.object({
  properties: z.optional(zSheetProperties)
})

/**
 * The specifications of a slicer.
 */
export const zSlicerSpec = z.object({
  applyToPivotTables: z.optional(z.boolean()),
  backgroundColor: z.optional(zColor),
  backgroundColorStyle: z.optional(zColorStyle),
  columnIndex: z.optional(z.int()),
  dataRange: z.optional(zGridRange),
  filterCriteria: z.optional(zFilterCriteria),
  horizontalAlignment: z.optional(
    z.enum(['HORIZONTAL_ALIGN_UNSPECIFIED', 'LEFT', 'CENTER', 'RIGHT'])
  ),
  textFormat: z.optional(zTextFormat),
  title: z.optional(z.string())
})

/**
 * A slicer in a sheet.
 */
export const zSlicer = z.object({
  position: z.optional(zEmbeddedObjectPosition),
  slicerId: z.optional(z.int()),
  spec: z.optional(zSlicerSpec)
})

/**
 * Adds a slicer to a sheet in the spreadsheet.
 */
export const zAddSlicerRequest = z.object({
  slicer: z.optional(zSlicer)
})

/**
 * The result of adding a slicer to a spreadsheet.
 */
export const zAddSlicerResponse = z.object({
  slicer: z.optional(zSlicer)
})

/**
 * A data source formula.
 */
export const zDataSourceFormula = z.object({
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSourceId: z.optional(z.string())
})

/**
 * A data source table, which allows the user to import a static table of data from the DataSource into Sheets. This is also known as "Extract" in the Sheets editor.
 */
export const zDataSourceTable = z.object({
  columnSelectionType: z.optional(
    z.enum(['DATA_SOURCE_TABLE_COLUMN_SELECTION_TYPE_UNSPECIFIED', 'SELECTED', 'SYNC_ALL'])
  ),
  columns: z.optional(z.array(zDataSourceColumnReference)),
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSourceId: z.optional(z.string()),
  filterSpecs: z.optional(z.array(zFilterSpec)),
  rowLimit: z.optional(z.int()),
  sortSpecs: z.optional(z.array(zSortSpec))
})

/**
 * A data validation rule.
 */
export const zDataValidationRule = z.object({
  condition: z.optional(zBooleanCondition),
  inputMessage: z.optional(z.string()),
  showCustomUi: z.optional(z.boolean()),
  strict: z.optional(z.boolean())
})

/**
 * An error in a cell.
 */
export const zErrorValue = z.object({
  message: z.optional(z.string()),
  type: z.optional(
    z.enum([
      'ERROR_TYPE_UNSPECIFIED',
      'ERROR',
      'NULL_VALUE',
      'DIVIDE_BY_ZERO',
      'VALUE',
      'REF',
      'NAME',
      'NUM',
      'N_A',
      'LOADING'
    ])
  )
})

/**
 * The kinds of value that a cell in a spreadsheet can have.
 */
export const zExtendedValue = z.object({
  boolValue: z.optional(z.boolean()),
  errorValue: z.optional(zErrorValue),
  formulaValue: z.optional(z.string()),
  numberValue: z.optional(z.number()),
  stringValue: z.optional(z.string())
})

/**
 * The count limit on rows or columns in the pivot group.
 */
export const zPivotGroupLimit = z.object({
  applyOrder: z.optional(z.int()),
  countLimit: z.optional(z.int())
})

/**
 * Allows you to organize the date-time values in a source data column into buckets based on selected parts of their date or time values. For example, consider a pivot table showing sales transactions by date: +----------+--------------+ | Date | SUM of Sales | +----------+--------------+ | 1/1/2017 | $621.14 | | 2/3/2017 | $708.84 | | 5/8/2017 | $326.84 | ... +----------+--------------+ Applying a date-time group rule with a DateTimeRuleType of YEAR_MONTH results in the following pivot table. +--------------+--------------+ | Grouped Date | SUM of Sales | +--------------+--------------+ | 2017-Jan | $53,731.78 | | 2017-Feb | $83,475.32 | | 2017-Mar | $94,385.05 | ... +--------------+--------------+
 */
export const zDateTimeRule = z.object({
  type: z.optional(
    z.enum([
      'DATE_TIME_RULE_TYPE_UNSPECIFIED',
      'SECOND',
      'MINUTE',
      'HOUR',
      'HOUR_MINUTE',
      'HOUR_MINUTE_AMPM',
      'DAY_OF_WEEK',
      'DAY_OF_YEAR',
      'DAY_OF_MONTH',
      'DAY_MONTH',
      'MONTH',
      'QUARTER',
      'YEAR',
      'YEAR_MONTH',
      'YEAR_QUARTER',
      'YEAR_MONTH_DAY'
    ])
  )
})

/**
 * Allows you to organize the numeric values in a source data column into buckets of a constant size. All values from HistogramRule.start to HistogramRule.end are placed into groups of size HistogramRule.interval. In addition, all values below HistogramRule.start are placed in one group, and all values above HistogramRule.end are placed in another. Only HistogramRule.interval is required, though if HistogramRule.start and HistogramRule.end are both provided, HistogramRule.start must be less than HistogramRule.end. For example, a pivot table showing average purchase amount by age that has 50+ rows: +-----+-------------------+ | Age | AVERAGE of Amount | +-----+-------------------+ | 16 | $27.13 | | 17 | $5.24 | | 18 | $20.15 | ... +-----+-------------------+ could be turned into a pivot table that looks like the one below by applying a histogram group rule with a HistogramRule.start of 25, an HistogramRule.interval of 20, and an HistogramRule.end of 65. +-------------+-------------------+ | Grouped Age | AVERAGE of Amount | +-------------+-------------------+ | < 25 | $19.34 | | 25-45 | $31.43 | | 45-65 | $35.87 | | > 65 | $27.55 | +-------------+-------------------+ | Grand Total | $29.12 | +-------------+-------------------+
 */
export const zHistogramRule = z.object({
  end: z.optional(z.number()),
  interval: z.optional(z.number()),
  start: z.optional(z.number())
})

/**
 * A group name and a list of items from the source data that should be placed in the group with this name.
 */
export const zManualRuleGroup = z.object({
  groupName: z.optional(zExtendedValue),
  items: z.optional(z.array(zExtendedValue))
})

/**
 * Allows you to manually organize the values in a source data column into buckets with names of your choosing. For example, a pivot table that aggregates population by state: +-------+-------------------+ | State | SUM of Population | +-------+-------------------+ | AK | 0.7 | | AL | 4.8 | | AR | 2.9 | ... +-------+-------------------+ could be turned into a pivot table that aggregates population by time zone by providing a list of groups (for example, groupName = 'Central', items = ['AL', 'AR', 'IA', ...]) to a manual group rule. Note that a similar effect could be achieved by adding a time zone column to the source data and adjusting the pivot table. +-----------+-------------------+ | Time Zone | SUM of Population | +-----------+-------------------+ | Central | 106.3 | | Eastern | 151.9 | | Mountain | 17.4 | ... +-----------+-------------------+
 */
export const zManualRule = z.object({
  groups: z.optional(z.array(zManualRuleGroup))
})

/**
 * An optional setting on a PivotGroup that defines buckets for the values in the source data column rather than breaking out each individual value. Only one PivotGroup with a group rule may be added for each column in the source data, though on any given column you may add both a PivotGroup that has a rule and a PivotGroup that does not.
 */
export const zPivotGroupRule = z.object({
  dateTimeRule: z.optional(zDateTimeRule),
  histogramRule: z.optional(zHistogramRule),
  manualRule: z.optional(zManualRule)
})

/**
 * Information about which values in a pivot group should be used for sorting.
 */
export const zPivotGroupSortValueBucket = z.object({
  buckets: z.optional(z.array(zExtendedValue)),
  valuesIndex: z.optional(z.int())
})

/**
 * Metadata about a value in a pivot grouping.
 */
export const zPivotGroupValueMetadata = z.object({
  collapsed: z.optional(z.boolean()),
  value: z.optional(zExtendedValue)
})

/**
 * A single grouping (either row or column) in a pivot table.
 */
export const zPivotGroup = z.object({
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  groupLimit: z.optional(zPivotGroupLimit),
  groupRule: z.optional(zPivotGroupRule),
  label: z.optional(z.string()),
  repeatHeadings: z.optional(z.boolean()),
  showTotals: z.optional(z.boolean()),
  sortOrder: z.optional(z.enum(['SORT_ORDER_UNSPECIFIED', 'ASCENDING', 'DESCENDING'])),
  sourceColumnOffset: z.optional(z.int()),
  valueBucket: z.optional(zPivotGroupSortValueBucket),
  valueMetadata: z.optional(z.array(zPivotGroupValueMetadata))
})

/**
 * Criteria for showing/hiding rows in a pivot table.
 */
export const zPivotFilterCriteria = z.object({
  condition: z.optional(zBooleanCondition),
  visibleByDefault: z.optional(z.boolean()),
  visibleValues: z.optional(z.array(z.string()))
})

/**
 * The pivot table filter criteria associated with a specific source column offset.
 */
export const zPivotFilterSpec = z.object({
  columnOffsetIndex: z.optional(z.int()),
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  filterCriteria: z.optional(zPivotFilterCriteria)
})

/**
 * The definition of how a value in a pivot table should be calculated.
 */
export const zPivotValue = z.object({
  calculatedDisplayType: z.optional(
    z.enum([
      'PIVOT_VALUE_CALCULATED_DISPLAY_TYPE_UNSPECIFIED',
      'PERCENT_OF_ROW_TOTAL',
      'PERCENT_OF_COLUMN_TOTAL',
      'PERCENT_OF_GRAND_TOTAL'
    ])
  ),
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  formula: z.optional(z.string()),
  name: z.optional(z.string()),
  sourceColumnOffset: z.optional(z.int()),
  summarizeFunction: z.optional(
    z.enum([
      'PIVOT_STANDARD_VALUE_FUNCTION_UNSPECIFIED',
      'SUM',
      'COUNTA',
      'COUNT',
      'COUNTUNIQUE',
      'AVERAGE',
      'MAX',
      'MIN',
      'MEDIAN',
      'PRODUCT',
      'STDEV',
      'STDEVP',
      'VAR',
      'VARP',
      'CUSTOM'
    ])
  )
})

/**
 * A pivot table.
 */
export const zPivotTable = z.object({
  columns: z.optional(z.array(zPivotGroup)),
  criteria: z.optional(z.record(z.string(), zPivotFilterCriteria)),
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSourceId: z.optional(z.string()),
  filterSpecs: z.optional(z.array(zPivotFilterSpec)),
  rows: z.optional(z.array(zPivotGroup)),
  source: z.optional(zGridRange),
  valueLayout: z.optional(z.enum(['HORIZONTAL', 'VERTICAL'])),
  values: z.optional(z.array(zPivotValue))
})

/**
 * A run of a text format. The format of this run continues until the start index of the next run. When updating, all fields must be set.
 */
export const zTextFormatRun = z.object({
  format: z.optional(zTextFormat),
  startIndex: z.optional(z.int())
})

/**
 * Data about a specific cell.
 */
export const zCellData = z.object({
  dataSourceFormula: z.optional(zDataSourceFormula),
  dataSourceTable: z.optional(zDataSourceTable),
  dataValidation: z.optional(zDataValidationRule),
  effectiveFormat: z.optional(zCellFormat),
  effectiveValue: z.optional(zExtendedValue),
  formattedValue: z.optional(z.string()),
  hyperlink: z.optional(z.string()),
  note: z.optional(z.string()),
  pivotTable: z.optional(zPivotTable),
  textFormatRuns: z.optional(z.array(zTextFormatRun)),
  userEnteredFormat: z.optional(zCellFormat),
  userEnteredValue: z.optional(zExtendedValue)
})

/**
 * Data about each cell in a row.
 */
export const zRowData = z.object({
  values: z.optional(z.array(zCellData))
})

/**
 * Adds new cells after the last row with data in a sheet, inserting new rows into the sheet if necessary.
 */
export const zAppendCellsRequest = z.object({
  fields: z.optional(z.string()),
  rows: z.optional(z.array(zRowData)),
  sheetId: z.optional(z.int())
})

/**
 * Appends rows or columns to the end of a sheet.
 */
export const zAppendDimensionRequest = z.object({
  dimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  length: z.optional(z.int()),
  sheetId: z.optional(z.int())
})

/**
 * Data within a range of the spreadsheet.
 */
export const zValueRange = z.object({
  majorDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  range: z.optional(z.string()),
  values: z.optional(z.array(z.array(z.unknown())))
})

/**
 * The response when updating a range of values in a spreadsheet.
 */
export const zUpdateValuesResponse = z.object({
  spreadsheetId: z.optional(z.string()),
  updatedCells: z.optional(z.int()),
  updatedColumns: z.optional(z.int()),
  updatedData: z.optional(zValueRange),
  updatedRange: z.optional(z.string()),
  updatedRows: z.optional(z.int())
})

/**
 * The response when updating a range of values in a spreadsheet.
 */
export const zAppendValuesResponse = z.object({
  spreadsheetId: z.optional(z.string()),
  tableRange: z.optional(z.string()),
  updates: z.optional(zUpdateValuesResponse)
})

/**
 * A combination of a source range and how to extend that source.
 */
export const zSourceAndDestination = z.object({
  dimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  fillLength: z.optional(z.int()),
  source: z.optional(zGridRange)
})

/**
 * Fills in more data based on existing data.
 */
export const zAutoFillRequest = z.object({
  range: z.optional(zGridRange),
  sourceAndDestination: z.optional(zSourceAndDestination),
  useAlternateSeries: z.optional(z.boolean())
})

/**
 * A range along a single dimension on a DATA_SOURCE sheet.
 */
export const zDataSourceSheetDimensionRange = z.object({
  columnReferences: z.optional(z.array(zDataSourceColumnReference)),
  sheetId: z.optional(z.int())
})

/**
 * Automatically resizes one or more dimensions based on the contents of the cells in that dimension.
 */
export const zAutoResizeDimensionsRequest = z.object({
  dataSourceSheetDimensions: z.optional(zDataSourceSheetDimensionRange),
  dimensions: z.optional(zDimensionRange)
})

/**
 * The default filter associated with a sheet.
 */
export const zBasicFilter = z.object({
  criteria: z.optional(z.record(z.string(), zFilterCriteria)),
  filterSpecs: z.optional(z.array(zFilterSpec)),
  range: z.optional(zGridRange),
  sortSpecs: z.optional(z.array(zSortSpec))
})

/**
 * A location where metadata may be associated in a spreadsheet.
 */
export const zDeveloperMetadataLocation = z.object({
  dimensionRange: z.optional(zDimensionRange),
  locationType: z.optional(
    z.enum([
      'DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED',
      'ROW',
      'COLUMN',
      'SHEET',
      'SPREADSHEET'
    ])
  ),
  sheetId: z.optional(z.int()),
  spreadsheet: z.optional(z.boolean())
})

/**
 * Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified.
 */
export const zDeveloperMetadataLookup = z.object({
  locationMatchingStrategy: z.optional(
    z.enum([
      'DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED',
      'EXACT_LOCATION',
      'INTERSECTING_LOCATION'
    ])
  ),
  locationType: z.optional(
    z.enum([
      'DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED',
      'ROW',
      'COLUMN',
      'SHEET',
      'SPREADSHEET'
    ])
  ),
  metadataId: z.optional(z.int()),
  metadataKey: z.optional(z.string()),
  metadataLocation: z.optional(zDeveloperMetadataLocation),
  metadataValue: z.optional(z.string()),
  visibility: z.optional(
    z.enum(['DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED', 'DOCUMENT', 'PROJECT'])
  )
})

/**
 * Filter that describes what data should be selected or returned from a request.
 */
export const zDataFilter = z.object({
  a1Range: z.optional(z.string()),
  developerMetadataLookup: z.optional(zDeveloperMetadataLookup),
  gridRange: z.optional(zGridRange)
})

/**
 * The request for clearing more than one range selected by a DataFilter in a spreadsheet.
 */
export const zBatchClearValuesByDataFilterRequest = z.object({
  dataFilters: z.optional(z.array(zDataFilter))
})

/**
 * The response when clearing a range of values selected with DataFilters in a spreadsheet.
 */
export const zBatchClearValuesByDataFilterResponse = z.object({
  clearedRanges: z.optional(z.array(z.string())),
  spreadsheetId: z.optional(z.string())
})

/**
 * The request for clearing more than one range of values in a spreadsheet.
 */
export const zBatchClearValuesRequest = z.object({
  ranges: z.optional(z.array(z.string()))
})

/**
 * The response when clearing a range of values in a spreadsheet.
 */
export const zBatchClearValuesResponse = z.object({
  clearedRanges: z.optional(z.array(z.string())),
  spreadsheetId: z.optional(z.string())
})

/**
 * The request for retrieving a range of values in a spreadsheet selected by a set of DataFilters.
 */
export const zBatchGetValuesByDataFilterRequest = z.object({
  dataFilters: z.optional(z.array(zDataFilter)),
  dateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
  majorDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  valueRenderOption: z.optional(z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA']))
})

/**
 * A value range that was matched by one or more data filers.
 */
export const zMatchedValueRange = z.object({
  dataFilters: z.optional(z.array(zDataFilter)),
  valueRange: z.optional(zValueRange)
})

/**
 * The response when retrieving more than one range of values in a spreadsheet selected by DataFilters.
 */
export const zBatchGetValuesByDataFilterResponse = z.object({
  spreadsheetId: z.optional(z.string()),
  valueRanges: z.optional(z.array(zMatchedValueRange))
})

/**
 * The response when retrieving more than one range of values in a spreadsheet.
 */
export const zBatchGetValuesResponse = z.object({
  spreadsheetId: z.optional(z.string()),
  valueRanges: z.optional(z.array(zValueRange))
})

/**
 * Clears the basic filter, if any exists on the sheet.
 */
export const zClearBasicFilterRequest = z.object({
  sheetId: z.optional(z.int())
})

/**
 * Copies data from the source to the destination.
 */
export const zCopyPasteRequest = z.object({
  destination: z.optional(zGridRange),
  pasteOrientation: z.optional(z.enum(['NORMAL', 'TRANSPOSE'])),
  pasteType: z.optional(
    z.enum([
      'PASTE_NORMAL',
      'PASTE_VALUES',
      'PASTE_FORMAT',
      'PASTE_NO_BORDERS',
      'PASTE_FORMULA',
      'PASTE_DATA_VALIDATION',
      'PASTE_CONDITIONAL_FORMATTING'
    ])
  ),
  source: z.optional(zGridRange)
})

/**
 * Developer metadata associated with a location or object in a spreadsheet. Developer metadata may be used to associate arbitrary data with various parts of a spreadsheet and will remain associated at those locations as they move around and the spreadsheet is edited. For example, if developer metadata is associated with row 5 and another row is then subsequently inserted above row 5, that original metadata will still be associated with the row it was first associated with (what is now row 6). If the associated object is deleted its metadata is deleted too.
 */
export const zDeveloperMetadata = z.object({
  location: z.optional(zDeveloperMetadataLocation),
  metadataId: z.optional(z.int()),
  metadataKey: z.optional(z.string()),
  metadataValue: z.optional(z.string()),
  visibility: z.optional(
    z.enum(['DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED', 'DOCUMENT', 'PROJECT'])
  )
})

/**
 * A request to create developer metadata.
 */
export const zCreateDeveloperMetadataRequest = z.object({
  developerMetadata: z.optional(zDeveloperMetadata)
})

/**
 * Moves data from the source to the destination.
 */
export const zCutPasteRequest = z.object({
  destination: z.optional(zGridCoordinate),
  pasteType: z.optional(
    z.enum([
      'PASTE_NORMAL',
      'PASTE_VALUES',
      'PASTE_FORMAT',
      'PASTE_NO_BORDERS',
      'PASTE_FORMULA',
      'PASTE_DATA_VALIDATION',
      'PASTE_CONDITIONAL_FORMATTING'
    ])
  ),
  source: z.optional(zGridRange)
})

/**
 * Removes the banded range with the given ID from the spreadsheet.
 */
export const zDeleteBandingRequest = z.object({
  bandedRangeId: z.optional(z.int())
})

/**
 * Deletes a conditional format rule at the given index. All subsequent rules' indexes are decremented.
 */
export const zDeleteConditionalFormatRuleRequest = z.object({
  index: z.optional(z.int()),
  sheetId: z.optional(z.int())
})

/**
 * Deletes a data source. The request also deletes the associated data source sheet, and unlinks all associated data source objects.
 */
export const zDeleteDataSourceRequest = z.object({
  dataSourceId: z.optional(z.string())
})

/**
 * A request to delete developer metadata.
 */
export const zDeleteDeveloperMetadataRequest = z.object({
  dataFilter: z.optional(zDataFilter)
})

/**
 * Deletes the dimensions from the sheet.
 */
export const zDeleteDimensionRequest = z.object({
  range: z.optional(zDimensionRange)
})

/**
 * Deletes a group over the specified range by decrementing the depth of the dimensions in the range. For example, assume the sheet has a depth-1 group over B:E and a depth-2 group over C:D. Deleting a group over D:E leaves the sheet with a depth-1 group over B:D and a depth-2 group over C:C.
 */
export const zDeleteDimensionGroupRequest = z.object({
  range: z.optional(zDimensionRange)
})

/**
 * Removes rows within this range that contain values in the specified columns that are duplicates of values in any previous row. Rows with identical values but different letter cases, formatting, or formulas are considered to be duplicates. This request also removes duplicate rows hidden from view (for example, due to a filter). When removing duplicates, the first instance of each duplicate row scanning from the top downwards is kept in the resulting range. Content outside of the specified range isn't removed, and rows considered duplicates do not have to be adjacent to each other in the range.
 */
export const zDeleteDuplicatesRequest = z.object({
  comparisonColumns: z.optional(z.array(zDimensionRange)),
  range: z.optional(zGridRange)
})

/**
 * Deletes the embedded object with the given ID.
 */
export const zDeleteEmbeddedObjectRequest = z.object({
  objectId: z.optional(z.int())
})

/**
 * Deletes a particular filter view.
 */
export const zDeleteFilterViewRequest = z.object({
  filterId: z.optional(z.int())
})

/**
 * Removes the named range with the given ID from the spreadsheet.
 */
export const zDeleteNamedRangeRequest = z.object({
  namedRangeId: z.optional(z.string())
})

/**
 * Deletes the protected range with the given ID.
 */
export const zDeleteProtectedRangeRequest = z.object({
  protectedRangeId: z.optional(z.int())
})

/**
 * Deletes a range of cells, shifting other cells into the deleted area.
 */
export const zDeleteRangeRequest = z.object({
  range: z.optional(zGridRange),
  shiftDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS']))
})

/**
 * Deletes the requested sheet.
 */
export const zDeleteSheetRequest = z.object({
  sheetId: z.optional(z.int())
})

/**
 * Duplicates a particular filter view.
 */
export const zDuplicateFilterViewRequest = z.object({
  filterId: z.optional(z.int())
})

/**
 * Duplicates the contents of a sheet.
 */
export const zDuplicateSheetRequest = z.object({
  insertSheetIndex: z.optional(z.int()),
  newSheetId: z.optional(z.int()),
  newSheetName: z.optional(z.string()),
  sourceSheetId: z.optional(z.int())
})

/**
 * Finds and replaces data in cells over a range, sheet, or all sheets.
 */
export const zFindReplaceRequest = z.object({
  allSheets: z.optional(z.boolean()),
  find: z.optional(z.string()),
  includeFormulas: z.optional(z.boolean()),
  matchCase: z.optional(z.boolean()),
  matchEntireCell: z.optional(z.boolean()),
  range: z.optional(zGridRange),
  replacement: z.optional(z.string()),
  searchByRegex: z.optional(z.boolean()),
  sheetId: z.optional(z.int())
})

/**
 * Inserts rows or columns in a sheet at a particular index.
 */
export const zInsertDimensionRequest = z.object({
  inheritFromBefore: z.optional(z.boolean()),
  range: z.optional(zDimensionRange)
})

/**
 * Inserts cells into a range, shifting the existing cells over or down.
 */
export const zInsertRangeRequest = z.object({
  range: z.optional(zGridRange),
  shiftDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS']))
})

/**
 * Merges all cells in the range.
 */
export const zMergeCellsRequest = z.object({
  mergeType: z.optional(z.enum(['MERGE_ALL', 'MERGE_COLUMNS', 'MERGE_ROWS'])),
  range: z.optional(zGridRange)
})

/**
 * Moves one or more rows or columns.
 */
export const zMoveDimensionRequest = z.object({
  destinationIndex: z.optional(z.int()),
  source: z.optional(zDimensionRange)
})

/**
 * Inserts data into the spreadsheet starting at the specified coordinate.
 */
export const zPasteDataRequest = z.object({
  coordinate: z.optional(zGridCoordinate),
  data: z.optional(z.string()),
  delimiter: z.optional(z.string()),
  html: z.optional(z.boolean()),
  type: z.optional(
    z.enum([
      'PASTE_NORMAL',
      'PASTE_VALUES',
      'PASTE_FORMAT',
      'PASTE_NO_BORDERS',
      'PASTE_FORMULA',
      'PASTE_DATA_VALIDATION',
      'PASTE_CONDITIONAL_FORMATTING'
    ])
  )
})

/**
 * Randomizes the order of the rows in a range.
 */
export const zRandomizeRangeRequest = z.object({
  range: z.optional(zGridRange)
})

/**
 * Reference to a data source object.
 */
export const zDataSourceObjectReference = z.object({
  chartId: z.optional(z.int()),
  dataSourceFormulaCell: z.optional(zGridCoordinate),
  dataSourcePivotTableAnchorCell: z.optional(zGridCoordinate),
  dataSourceTableAnchorCell: z.optional(zGridCoordinate),
  sheetId: z.optional(z.string())
})

/**
 * A list of references to data source objects.
 */
export const zDataSourceObjectReferences = z.object({
  references: z.optional(z.array(zDataSourceObjectReference))
})

/**
 * Refreshes one or multiple data source objects in the spreadsheet by the specified references. The request requires an additional `bigquery.readonly` OAuth scope. If there are multiple refresh requests referencing the same data source objects in one batch, only the last refresh request is processed, and all those requests will have the same response accordingly.
 */
export const zRefreshDataSourceRequest = z.object({
  dataSourceId: z.optional(z.string()),
  force: z.optional(z.boolean()),
  isAll: z.optional(z.boolean()),
  references: z.optional(zDataSourceObjectReferences)
})

/**
 * Updates all cells in the range to the values in the given Cell object. Only the fields listed in the fields field are updated; others are unchanged. If writing a cell with a formula, the formula's ranges will automatically increment for each field in the range. For example, if writing a cell with formula `=A1` into range B2:C4, B2 would be `=A1`, B3 would be `=A2`, B4 would be `=A3`, C2 would be `=B1`, C3 would be `=B2`, C4 would be `=B3`. To keep the formula's ranges static, use the `$` indicator. For example, use the formula `=$A$1` to prevent both the row and the column from incrementing.
 */
export const zRepeatCellRequest = z.object({
  cell: z.optional(zCellData),
  fields: z.optional(z.string()),
  range: z.optional(zGridRange)
})

/**
 * Sets the basic filter associated with a sheet.
 */
export const zSetBasicFilterRequest = z.object({
  filter: z.optional(zBasicFilter)
})

/**
 * Sets a data validation rule to every cell in the range. To clear validation in a range, call this with no rule specified.
 */
export const zSetDataValidationRequest = z.object({
  range: z.optional(zGridRange),
  rule: z.optional(zDataValidationRule)
})

/**
 * Sorts data in rows based on a sort order per column.
 */
export const zSortRangeRequest = z.object({
  range: z.optional(zGridRange),
  sortSpecs: z.optional(z.array(zSortSpec))
})

/**
 * Splits a column of text into multiple columns, based on a delimiter in each cell.
 */
export const zTextToColumnsRequest = z.object({
  delimiter: z.optional(z.string()),
  delimiterType: z.optional(
    z.enum([
      'DELIMITER_TYPE_UNSPECIFIED',
      'COMMA',
      'SEMICOLON',
      'PERIOD',
      'SPACE',
      'CUSTOM',
      'AUTODETECT'
    ])
  ),
  source: z.optional(zGridRange)
})

/**
 * Trims the whitespace (such as spaces, tabs, or new lines) in every cell in the specified range. This request removes all whitespace from the start and end of each cell's text, and reduces any subsequence of remaining whitespace characters to a single space. If the resulting trimmed text starts with a '+' or '=' character, the text remains as a string value and isn't interpreted as a formula.
 */
export const zTrimWhitespaceRequest = z.object({
  range: z.optional(zGridRange)
})

/**
 * Unmerges cells in the given range.
 */
export const zUnmergeCellsRequest = z.object({
  range: z.optional(zGridRange)
})

/**
 * Updates properties of the supplied banded range.
 */
export const zUpdateBandingRequest = z.object({
  bandedRange: z.optional(zBandedRange),
  fields: z.optional(z.string())
})

/**
 * Updates the borders of a range. If a field is not set in the request, that means the border remains as-is. For example, with two subsequent UpdateBordersRequest: 1. range: A1:A5 `{ top: RED, bottom: WHITE }` 2. range: A1:A5 `{ left: BLUE }` That would result in A1:A5 having a borders of `{ top: RED, bottom: WHITE, left: BLUE }`. If you want to clear a border, explicitly set the style to NONE.
 */
export const zUpdateBordersRequest = z.object({
  bottom: z.optional(zBorder),
  innerHorizontal: z.optional(zBorder),
  innerVertical: z.optional(zBorder),
  left: z.optional(zBorder),
  range: z.optional(zGridRange),
  right: z.optional(zBorder),
  top: z.optional(zBorder)
})

/**
 * Updates all cells in a range with new data.
 */
export const zUpdateCellsRequest = z.object({
  fields: z.optional(z.string()),
  range: z.optional(zGridRange),
  rows: z.optional(z.array(zRowData)),
  start: z.optional(zGridCoordinate)
})

/**
 * Updates a chart's specifications. (This does not move or resize a chart. To move or resize a chart, use UpdateEmbeddedObjectPositionRequest.)
 */
export const zUpdateChartSpecRequest = z.object({
  chartId: z.optional(z.int()),
  spec: z.optional(zChartSpec)
})

/**
 * Updates a conditional format rule at the given index, or moves a conditional format rule to another index.
 */
export const zUpdateConditionalFormatRuleRequest = z.object({
  index: z.optional(z.int()),
  newIndex: z.optional(z.int()),
  rule: z.optional(zConditionalFormatRule),
  sheetId: z.optional(z.int())
})

/**
 * Updates a data source. After the data source is updated successfully, an execution is triggered to refresh the associated DATA_SOURCE sheet to read data from the updated data source. The request requires an additional `bigquery.readonly` OAuth scope.
 */
export const zUpdateDataSourceRequest = z.object({
  dataSource: z.optional(zDataSource),
  fields: z.optional(z.string())
})

/**
 * A request to update properties of developer metadata. Updates the properties of the developer metadata selected by the filters to the values provided in the DeveloperMetadata resource. Callers must specify the properties they wish to update in the fields parameter, as well as specify at least one DataFilter matching the metadata they wish to update.
 */
export const zUpdateDeveloperMetadataRequest = z.object({
  dataFilters: z.optional(z.array(zDataFilter)),
  developerMetadata: z.optional(zDeveloperMetadata),
  fields: z.optional(z.string())
})

/**
 * Updates the state of the specified group.
 */
export const zUpdateDimensionGroupRequest = z.object({
  dimensionGroup: z.optional(zDimensionGroup),
  fields: z.optional(z.string())
})

/**
 * Properties about a dimension.
 */
export const zDimensionProperties = z.object({
  dataSourceColumnReference: z.optional(zDataSourceColumnReference),
  developerMetadata: z.optional(z.array(zDeveloperMetadata)),
  hiddenByFilter: z.optional(z.boolean()),
  hiddenByUser: z.optional(z.boolean()),
  pixelSize: z.optional(z.int())
})

/**
 * Updates properties of dimensions within the specified range.
 */
export const zUpdateDimensionPropertiesRequest = z.object({
  dataSourceSheetRange: z.optional(zDataSourceSheetDimensionRange),
  fields: z.optional(z.string()),
  properties: z.optional(zDimensionProperties),
  range: z.optional(zDimensionRange)
})

/**
 * Updates an embedded object's border property.
 */
export const zUpdateEmbeddedObjectBorderRequest = z.object({
  border: z.optional(zEmbeddedObjectBorder),
  fields: z.optional(z.string()),
  objectId: z.optional(z.int())
})

/**
 * Update an embedded object's position (such as a moving or resizing a chart or image).
 */
export const zUpdateEmbeddedObjectPositionRequest = z.object({
  fields: z.optional(z.string()),
  newPosition: z.optional(zEmbeddedObjectPosition),
  objectId: z.optional(z.int())
})

/**
 * Updates properties of the filter view.
 */
export const zUpdateFilterViewRequest = z.object({
  fields: z.optional(z.string()),
  filter: z.optional(zFilterView)
})

/**
 * Updates properties of the named range with the specified namedRangeId.
 */
export const zUpdateNamedRangeRequest = z.object({
  fields: z.optional(z.string()),
  namedRange: z.optional(zNamedRange)
})

/**
 * Updates an existing protected range with the specified protectedRangeId.
 */
export const zUpdateProtectedRangeRequest = z.object({
  fields: z.optional(z.string()),
  protectedRange: z.optional(zProtectedRange)
})

/**
 * Updates properties of the sheet with the specified sheetId.
 */
export const zUpdateSheetPropertiesRequest = z.object({
  fields: z.optional(z.string()),
  properties: z.optional(zSheetProperties)
})

/**
 * Updates a slicer's specifications. (This does not move or resize a slicer. To move or resize a slicer use UpdateEmbeddedObjectPositionRequest.
 */
export const zUpdateSlicerSpecRequest = z.object({
  fields: z.optional(z.string()),
  slicerId: z.optional(z.int()),
  spec: z.optional(zSlicerSpec)
})

/**
 * Settings to control how circular dependencies are resolved with iterative calculation.
 */
export const zIterativeCalculationSettings = z.object({
  convergenceThreshold: z.optional(z.number()),
  maxIterations: z.optional(z.int())
})

/**
 * A pair mapping a spreadsheet theme color type to the concrete color it represents.
 */
export const zThemeColorPair = z.object({
  color: z.optional(zColorStyle),
  colorType: z.optional(
    z.enum([
      'THEME_COLOR_TYPE_UNSPECIFIED',
      'TEXT',
      'BACKGROUND',
      'ACCENT1',
      'ACCENT2',
      'ACCENT3',
      'ACCENT4',
      'ACCENT5',
      'ACCENT6',
      'LINK'
    ])
  )
})

/**
 * Represents spreadsheet theme
 */
export const zSpreadsheetTheme = z.object({
  primaryFontFamily: z.optional(z.string()),
  themeColors: z.optional(z.array(zThemeColorPair))
})

/**
 * Properties of a spreadsheet.
 */
export const zSpreadsheetProperties = z.object({
  autoRecalc: z.optional(
    z.enum(['RECALCULATION_INTERVAL_UNSPECIFIED', 'ON_CHANGE', 'MINUTE', 'HOUR'])
  ),
  defaultFormat: z.optional(zCellFormat),
  iterativeCalculationSettings: z.optional(zIterativeCalculationSettings),
  locale: z.optional(z.string()),
  spreadsheetTheme: z.optional(zSpreadsheetTheme),
  timeZone: z.optional(z.string()),
  title: z.optional(z.string())
})

/**
 * Updates properties of a spreadsheet.
 */
export const zUpdateSpreadsheetPropertiesRequest = z.object({
  fields: z.optional(z.string()),
  properties: z.optional(zSpreadsheetProperties)
})

/**
 * A single kind of update to apply to a spreadsheet.
 */
export const zRequest = z.object({
  addBanding: z.optional(zAddBandingRequest),
  addChart: z.optional(zAddChartRequest),
  addConditionalFormatRule: z.optional(zAddConditionalFormatRuleRequest),
  addDataSource: z.optional(zAddDataSourceRequest),
  addDimensionGroup: z.optional(zAddDimensionGroupRequest),
  addFilterView: z.optional(zAddFilterViewRequest),
  addNamedRange: z.optional(zAddNamedRangeRequest),
  addProtectedRange: z.optional(zAddProtectedRangeRequest),
  addSheet: z.optional(zAddSheetRequest),
  addSlicer: z.optional(zAddSlicerRequest),
  appendCells: z.optional(zAppendCellsRequest),
  appendDimension: z.optional(zAppendDimensionRequest),
  autoFill: z.optional(zAutoFillRequest),
  autoResizeDimensions: z.optional(zAutoResizeDimensionsRequest),
  clearBasicFilter: z.optional(zClearBasicFilterRequest),
  copyPaste: z.optional(zCopyPasteRequest),
  createDeveloperMetadata: z.optional(zCreateDeveloperMetadataRequest),
  cutPaste: z.optional(zCutPasteRequest),
  deleteBanding: z.optional(zDeleteBandingRequest),
  deleteConditionalFormatRule: z.optional(zDeleteConditionalFormatRuleRequest),
  deleteDataSource: z.optional(zDeleteDataSourceRequest),
  deleteDeveloperMetadata: z.optional(zDeleteDeveloperMetadataRequest),
  deleteDimension: z.optional(zDeleteDimensionRequest),
  deleteDimensionGroup: z.optional(zDeleteDimensionGroupRequest),
  deleteDuplicates: z.optional(zDeleteDuplicatesRequest),
  deleteEmbeddedObject: z.optional(zDeleteEmbeddedObjectRequest),
  deleteFilterView: z.optional(zDeleteFilterViewRequest),
  deleteNamedRange: z.optional(zDeleteNamedRangeRequest),
  deleteProtectedRange: z.optional(zDeleteProtectedRangeRequest),
  deleteRange: z.optional(zDeleteRangeRequest),
  deleteSheet: z.optional(zDeleteSheetRequest),
  duplicateFilterView: z.optional(zDuplicateFilterViewRequest),
  duplicateSheet: z.optional(zDuplicateSheetRequest),
  findReplace: z.optional(zFindReplaceRequest),
  insertDimension: z.optional(zInsertDimensionRequest),
  insertRange: z.optional(zInsertRangeRequest),
  mergeCells: z.optional(zMergeCellsRequest),
  moveDimension: z.optional(zMoveDimensionRequest),
  pasteData: z.optional(zPasteDataRequest),
  randomizeRange: z.optional(zRandomizeRangeRequest),
  refreshDataSource: z.optional(zRefreshDataSourceRequest),
  repeatCell: z.optional(zRepeatCellRequest),
  setBasicFilter: z.optional(zSetBasicFilterRequest),
  setDataValidation: z.optional(zSetDataValidationRequest),
  sortRange: z.optional(zSortRangeRequest),
  textToColumns: z.optional(zTextToColumnsRequest),
  trimWhitespace: z.optional(zTrimWhitespaceRequest),
  unmergeCells: z.optional(zUnmergeCellsRequest),
  updateBanding: z.optional(zUpdateBandingRequest),
  updateBorders: z.optional(zUpdateBordersRequest),
  updateCells: z.optional(zUpdateCellsRequest),
  updateChartSpec: z.optional(zUpdateChartSpecRequest),
  updateConditionalFormatRule: z.optional(zUpdateConditionalFormatRuleRequest),
  updateDataSource: z.optional(zUpdateDataSourceRequest),
  updateDeveloperMetadata: z.optional(zUpdateDeveloperMetadataRequest),
  updateDimensionGroup: z.optional(zUpdateDimensionGroupRequest),
  updateDimensionProperties: z.optional(zUpdateDimensionPropertiesRequest),
  updateEmbeddedObjectBorder: z.optional(zUpdateEmbeddedObjectBorderRequest),
  updateEmbeddedObjectPosition: z.optional(zUpdateEmbeddedObjectPositionRequest),
  updateFilterView: z.optional(zUpdateFilterViewRequest),
  updateNamedRange: z.optional(zUpdateNamedRangeRequest),
  updateProtectedRange: z.optional(zUpdateProtectedRangeRequest),
  updateSheetProperties: z.optional(zUpdateSheetPropertiesRequest),
  updateSlicerSpec: z.optional(zUpdateSlicerSpecRequest),
  updateSpreadsheetProperties: z.optional(zUpdateSpreadsheetPropertiesRequest)
})

/**
 * The request for updating any aspect of a spreadsheet.
 */
export const zBatchUpdateSpreadsheetRequest = z.object({
  includeSpreadsheetInResponse: z.optional(z.boolean()),
  requests: z.optional(z.array(zRequest)),
  responseIncludeGridData: z.optional(z.boolean()),
  responseRanges: z.optional(z.array(z.string()))
})

/**
 * The response from creating developer metadata.
 */
export const zCreateDeveloperMetadataResponse = z.object({
  developerMetadata: z.optional(zDeveloperMetadata)
})

/**
 * The result of deleting a conditional format rule.
 */
export const zDeleteConditionalFormatRuleResponse = z.object({
  rule: z.optional(zConditionalFormatRule)
})

/**
 * The response from deleting developer metadata.
 */
export const zDeleteDeveloperMetadataResponse = z.object({
  deletedDeveloperMetadata: z.optional(z.array(zDeveloperMetadata))
})

/**
 * The result of deleting a group.
 */
export const zDeleteDimensionGroupResponse = z.object({
  dimensionGroups: z.optional(z.array(zDimensionGroup))
})

/**
 * The result of removing duplicates in a range.
 */
export const zDeleteDuplicatesResponse = z.object({
  duplicatesRemovedCount: z.optional(z.int())
})

/**
 * The result of a filter view being duplicated.
 */
export const zDuplicateFilterViewResponse = z.object({
  filter: z.optional(zFilterView)
})

/**
 * The result of duplicating a sheet.
 */
export const zDuplicateSheetResponse = z.object({
  properties: z.optional(zSheetProperties)
})

/**
 * The result of the find/replace.
 */
export const zFindReplaceResponse = z.object({
  formulasChanged: z.optional(z.int()),
  occurrencesChanged: z.optional(z.int()),
  rowsChanged: z.optional(z.int()),
  sheetsChanged: z.optional(z.int()),
  valuesChanged: z.optional(z.int())
})

/**
 * The execution status of refreshing one data source object.
 */
export const zRefreshDataSourceObjectExecutionStatus = z.object({
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  reference: z.optional(zDataSourceObjectReference)
})

/**
 * The response from refreshing one or multiple data source objects.
 */
export const zRefreshDataSourceResponse = z.object({
  statuses: z.optional(z.array(zRefreshDataSourceObjectExecutionStatus))
})

/**
 * The result of trimming whitespace in cells.
 */
export const zTrimWhitespaceResponse = z.object({
  cellsChangedCount: z.optional(z.int())
})

/**
 * The result of updating a conditional format rule.
 */
export const zUpdateConditionalFormatRuleResponse = z.object({
  newIndex: z.optional(z.int()),
  newRule: z.optional(zConditionalFormatRule),
  oldIndex: z.optional(z.int()),
  oldRule: z.optional(zConditionalFormatRule)
})

/**
 * The response from updating data source.
 */
export const zUpdateDataSourceResponse = z.object({
  dataExecutionStatus: z.optional(zDataExecutionStatus),
  dataSource: z.optional(zDataSource)
})

/**
 * The response from updating developer metadata.
 */
export const zUpdateDeveloperMetadataResponse = z.object({
  developerMetadata: z.optional(z.array(zDeveloperMetadata))
})

/**
 * The result of updating an embedded object's position.
 */
export const zUpdateEmbeddedObjectPositionResponse = z.object({
  position: z.optional(zEmbeddedObjectPosition)
})

/**
 * A single response from an update.
 */
export const zResponse = z.object({
  addBanding: z.optional(zAddBandingResponse),
  addChart: z.optional(zAddChartResponse),
  addDataSource: z.optional(zAddDataSourceResponse),
  addDimensionGroup: z.optional(zAddDimensionGroupResponse),
  addFilterView: z.optional(zAddFilterViewResponse),
  addNamedRange: z.optional(zAddNamedRangeResponse),
  addProtectedRange: z.optional(zAddProtectedRangeResponse),
  addSheet: z.optional(zAddSheetResponse),
  addSlicer: z.optional(zAddSlicerResponse),
  createDeveloperMetadata: z.optional(zCreateDeveloperMetadataResponse),
  deleteConditionalFormatRule: z.optional(zDeleteConditionalFormatRuleResponse),
  deleteDeveloperMetadata: z.optional(zDeleteDeveloperMetadataResponse),
  deleteDimensionGroup: z.optional(zDeleteDimensionGroupResponse),
  deleteDuplicates: z.optional(zDeleteDuplicatesResponse),
  duplicateFilterView: z.optional(zDuplicateFilterViewResponse),
  duplicateSheet: z.optional(zDuplicateSheetResponse),
  findReplace: z.optional(zFindReplaceResponse),
  refreshDataSource: z.optional(zRefreshDataSourceResponse),
  trimWhitespace: z.optional(zTrimWhitespaceResponse),
  updateConditionalFormatRule: z.optional(zUpdateConditionalFormatRuleResponse),
  updateDataSource: z.optional(zUpdateDataSourceResponse),
  updateDeveloperMetadata: z.optional(zUpdateDeveloperMetadataResponse),
  updateEmbeddedObjectPosition: z.optional(zUpdateEmbeddedObjectPositionResponse)
})

/**
 * Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
 */
export const zTimeOfDay = z.object({
  hours: z.optional(z.int()),
  minutes: z.optional(z.int()),
  nanos: z.optional(z.int()),
  seconds: z.optional(z.int())
})

/**
 * A schedule for data to refresh every day in a given time interval.
 */
export const zDataSourceRefreshDailySchedule = z.object({
  startTime: z.optional(zTimeOfDay)
})

/**
 * A monthly schedule for data to refresh on specific days in the month in a given time interval.
 */
export const zDataSourceRefreshMonthlySchedule = z.object({
  daysOfMonth: z.optional(z.array(z.int())),
  startTime: z.optional(zTimeOfDay)
})

/**
 * Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
 */
export const zInterval = z.object({
  endTime: z.optional(z.string()),
  startTime: z.optional(z.string())
})

/**
 * A weekly schedule for data to refresh on specific days in a given time interval.
 */
export const zDataSourceRefreshWeeklySchedule = z.object({
  daysOfWeek: z.optional(
    z.array(
      z.enum([
        'DAY_OF_WEEK_UNSPECIFIED',
        'MONDAY',
        'TUESDAY',
        'WEDNESDAY',
        'THURSDAY',
        'FRIDAY',
        'SATURDAY',
        'SUNDAY'
      ])
    )
  ),
  startTime: z.optional(zTimeOfDay)
})

/**
 * Schedule for refreshing the data source. Data sources in the spreadsheet are refreshed within a time interval. You can specify the start time by clicking the Scheduled Refresh button in the Sheets editor, but the interval is fixed at 4 hours. For example, if you specify a start time of 8am , the refresh will take place between 8am and 12pm every day.
 */
export const zDataSourceRefreshSchedule = z.object({
  dailySchedule: z.optional(zDataSourceRefreshDailySchedule),
  enabled: z.optional(z.boolean()),
  monthlySchedule: z.optional(zDataSourceRefreshMonthlySchedule),
  nextRun: z.optional(zInterval),
  refreshScope: z.optional(z.enum(['DATA_SOURCE_REFRESH_SCOPE_UNSPECIFIED', 'ALL_DATA_SOURCES'])),
  weeklySchedule: z.optional(zDataSourceRefreshWeeklySchedule)
})

/**
 * Data in the grid, as well as metadata about the dimensions.
 */
export const zGridData = z.object({
  columnMetadata: z.optional(z.array(zDimensionProperties)),
  rowData: z.optional(z.array(zRowData)),
  rowMetadata: z.optional(z.array(zDimensionProperties)),
  startColumn: z.optional(z.int()),
  startRow: z.optional(z.int())
})

/**
 * A sheet in a spreadsheet.
 */
export const zSheet = z.object({
  bandedRanges: z.optional(z.array(zBandedRange)),
  basicFilter: z.optional(zBasicFilter),
  charts: z.optional(z.array(zEmbeddedChart)),
  columnGroups: z.optional(z.array(zDimensionGroup)),
  conditionalFormats: z.optional(z.array(zConditionalFormatRule)),
  data: z.optional(z.array(zGridData)),
  developerMetadata: z.optional(z.array(zDeveloperMetadata)),
  filterViews: z.optional(z.array(zFilterView)),
  merges: z.optional(z.array(zGridRange)),
  properties: z.optional(zSheetProperties),
  protectedRanges: z.optional(z.array(zProtectedRange)),
  rowGroups: z.optional(z.array(zDimensionGroup)),
  slicers: z.optional(z.array(zSlicer))
})

/**
 * Resource that represents a spreadsheet.
 */
export const zSpreadsheet = z.object({
  dataSourceSchedules: z.optional(z.array(zDataSourceRefreshSchedule).readonly()),
  dataSources: z.optional(z.array(zDataSource)),
  developerMetadata: z.optional(z.array(zDeveloperMetadata)),
  namedRanges: z.optional(z.array(zNamedRange)),
  properties: z.optional(zSpreadsheetProperties),
  sheets: z.optional(z.array(zSheet)),
  spreadsheetId: z.optional(z.string()),
  spreadsheetUrl: z.optional(z.string())
})

/**
 * The reply for batch updating a spreadsheet.
 */
export const zBatchUpdateSpreadsheetResponse = z.object({
  replies: z.optional(z.array(zResponse)),
  spreadsheetId: z.optional(z.string()),
  updatedSpreadsheet: z.optional(zSpreadsheet)
})

/**
 * A range of values whose location is specified by a DataFilter.
 */
export const zDataFilterValueRange = z.object({
  dataFilter: z.optional(zDataFilter),
  majorDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
  values: z.optional(z.array(z.array(z.unknown())))
})

/**
 * The request for updating more than one range of values in a spreadsheet.
 */
export const zBatchUpdateValuesByDataFilterRequest = z.object({
  data: z.optional(z.array(zDataFilterValueRange)),
  includeValuesInResponse: z.optional(z.boolean()),
  responseDateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
  responseValueRenderOption: z.optional(
    z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA'])
  ),
  valueInputOption: z.optional(z.enum(['INPUT_VALUE_OPTION_UNSPECIFIED', 'RAW', 'USER_ENTERED']))
})

/**
 * The response when updating a range of values by a data filter in a spreadsheet.
 */
export const zUpdateValuesByDataFilterResponse = z.object({
  dataFilter: z.optional(zDataFilter),
  updatedCells: z.optional(z.int()),
  updatedColumns: z.optional(z.int()),
  updatedData: z.optional(zValueRange),
  updatedRange: z.optional(z.string()),
  updatedRows: z.optional(z.int())
})

/**
 * The response when updating a range of values in a spreadsheet.
 */
export const zBatchUpdateValuesByDataFilterResponse = z.object({
  responses: z.optional(z.array(zUpdateValuesByDataFilterResponse)),
  spreadsheetId: z.optional(z.string()),
  totalUpdatedCells: z.optional(z.int()),
  totalUpdatedColumns: z.optional(z.int()),
  totalUpdatedRows: z.optional(z.int()),
  totalUpdatedSheets: z.optional(z.int())
})

/**
 * The request for updating more than one range of values in a spreadsheet.
 */
export const zBatchUpdateValuesRequest = z.object({
  data: z.optional(z.array(zValueRange)),
  includeValuesInResponse: z.optional(z.boolean()),
  responseDateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
  responseValueRenderOption: z.optional(
    z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA'])
  ),
  valueInputOption: z.optional(z.enum(['INPUT_VALUE_OPTION_UNSPECIFIED', 'RAW', 'USER_ENTERED']))
})

/**
 * The response when updating a range of values in a spreadsheet.
 */
export const zBatchUpdateValuesResponse = z.object({
  responses: z.optional(z.array(zUpdateValuesResponse)),
  spreadsheetId: z.optional(z.string()),
  totalUpdatedCells: z.optional(z.int()),
  totalUpdatedColumns: z.optional(z.int()),
  totalUpdatedRows: z.optional(z.int()),
  totalUpdatedSheets: z.optional(z.int())
})

/**
 * The request for clearing a range of values in a spreadsheet.
 */
export const zClearValuesRequest = z.record(z.string(), z.unknown())

/**
 * The response when clearing a range of values in a spreadsheet.
 */
export const zClearValuesResponse = z.object({
  clearedRange: z.optional(z.string()),
  spreadsheetId: z.optional(z.string())
})

/**
 * The request to copy a sheet across spreadsheets.
 */
export const zCopySheetToAnotherSpreadsheetRequest = z.object({
  destinationSpreadsheetId: z.optional(z.string())
})

/**
 * The request for retrieving a Spreadsheet.
 */
export const zGetSpreadsheetByDataFilterRequest = z.object({
  dataFilters: z.optional(z.array(zDataFilter)),
  includeGridData: z.optional(z.boolean())
})

/**
 * A developer metadata entry and the data filters specified in the original request that matched it.
 */
export const zMatchedDeveloperMetadata = z.object({
  dataFilters: z.optional(z.array(zDataFilter)),
  developerMetadata: z.optional(zDeveloperMetadata)
})

/**
 * A request to retrieve all developer metadata matching the set of specified criteria.
 */
export const zSearchDeveloperMetadataRequest = z.object({
  dataFilters: z.optional(z.array(zDataFilter))
})

/**
 * A reply to a developer metadata search request.
 */
export const zSearchDeveloperMetadataResponse = z.object({
  matchedDeveloperMetadata: z.optional(z.array(zMatchedDeveloperMetadata))
})

/**
 * A data source table, which allows the user to import a static table of data from the DataSource into Sheets. This is also known as "Extract" in the Sheets editor.
 */
export const zDataSourceTableWritable = z.object({
  columnSelectionType: z.optional(
    z.enum(['DATA_SOURCE_TABLE_COLUMN_SELECTION_TYPE_UNSPECIFIED', 'SELECTED', 'SYNC_ALL'])
  ),
  columns: z.optional(z.array(zDataSourceColumnReference)),
  dataSourceId: z.optional(z.string()),
  filterSpecs: z.optional(z.array(zFilterSpec)),
  rowLimit: z.optional(z.int()),
  sortSpecs: z.optional(z.array(zSortSpec))
})

/**
 * A pivot table.
 */
export const zPivotTableWritable = z.object({
  columns: z.optional(z.array(zPivotGroup)),
  criteria: z.optional(z.record(z.string(), zPivotFilterCriteria)),
  dataSourceId: z.optional(z.string()),
  filterSpecs: z.optional(z.array(zPivotFilterSpec)),
  rows: z.optional(z.array(zPivotGroup)),
  source: z.optional(zGridRange),
  valueLayout: z.optional(z.enum(['HORIZONTAL', 'VERTICAL'])),
  values: z.optional(z.array(zPivotValue))
})

/**
 * Data about a specific cell.
 */
export const zCellDataWritable = z.object({
  dataSourceTable: z.optional(zDataSourceTableWritable),
  dataValidation: z.optional(zDataValidationRule),
  effectiveFormat: z.optional(zCellFormat),
  effectiveValue: z.optional(zExtendedValue),
  formattedValue: z.optional(z.string()),
  hyperlink: z.optional(z.string()),
  note: z.optional(z.string()),
  pivotTable: z.optional(zPivotTableWritable),
  textFormatRuns: z.optional(z.array(zTextFormatRun)),
  userEnteredFormat: z.optional(zCellFormat),
  userEnteredValue: z.optional(zExtendedValue)
})

/**
 * The request for clearing a range of values in a spreadsheet.
 */
export const zClearValuesRequestWritable = z.record(z.string(), z.unknown())

/**
 * Properties of a data source chart.
 */
export const zDataSourceChartPropertiesWritable = z.object({
  dataSourceId: z.optional(z.string())
})

/**
 * A data source formula.
 */
export const zDataSourceFormulaWritable = z.object({
  dataSourceId: z.optional(z.string())
})

/**
 * Schedule for refreshing the data source. Data sources in the spreadsheet are refreshed within a time interval. You can specify the start time by clicking the Scheduled Refresh button in the Sheets editor, but the interval is fixed at 4 hours. For example, if you specify a start time of 8am , the refresh will take place between 8am and 12pm every day.
 */
export const zDataSourceRefreshScheduleWritable = z.object({
  dailySchedule: z.optional(zDataSourceRefreshDailySchedule),
  enabled: z.optional(z.boolean()),
  monthlySchedule: z.optional(zDataSourceRefreshMonthlySchedule),
  refreshScope: z.optional(z.enum(['DATA_SOURCE_REFRESH_SCOPE_UNSPECIFIED', 'ALL_DATA_SOURCES'])),
  weeklySchedule: z.optional(zDataSourceRefreshWeeklySchedule)
})

/**
 * Properties about a dimension.
 */
export const zDimensionPropertiesWritable = z.object({
  developerMetadata: z.optional(z.array(zDeveloperMetadata)),
  hiddenByFilter: z.optional(z.boolean()),
  hiddenByUser: z.optional(z.boolean()),
  pixelSize: z.optional(z.int())
})

/**
 * Properties of a sheet.
 */
export const zSheetPropertiesWritable = z.object({
  gridProperties: z.optional(zGridProperties),
  hidden: z.optional(z.boolean()),
  index: z.optional(z.int()),
  rightToLeft: z.optional(z.boolean()),
  sheetId: z.optional(z.int()),
  sheetType: z.optional(z.enum(['SHEET_TYPE_UNSPECIFIED', 'GRID', 'OBJECT', 'DATA_SOURCE'])),
  tabColor: z.optional(zColor),
  tabColorStyle: z.optional(zColorStyle),
  title: z.optional(z.string())
})

/**
 * Resource that represents a spreadsheet.
 */
export const zSpreadsheetWritable = z.object({
  dataSources: z.optional(z.array(zDataSource)),
  developerMetadata: z.optional(z.array(zDeveloperMetadata)),
  namedRanges: z.optional(z.array(zNamedRange)),
  properties: z.optional(zSpreadsheetProperties),
  sheets: z.optional(z.array(zSheet)),
  spreadsheetId: z.optional(z.string()),
  spreadsheetUrl: z.optional(z.string())
})

/**
 * V1 error format.
 */
export const zXgafv = z.enum(['1', '2'])

/**
 * OAuth access token.
 */
export const zAccessToken = z.string()

/**
 * Data format for response.
 */
export const zAlt = z.enum(['json', 'media', 'proto'])

/**
 * JSONP
 */
export const zCallback = z.string()

/**
 * Selector specifying which fields to include in a partial response.
 */
export const zFields = z.string()

/**
 * API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
 */
export const zKey = z.string()

/**
 * OAuth 2.0 token for the current user.
 */
export const zOauthToken = z.string()

/**
 * Returns response with indentations and line breaks.
 */
export const zPrettyPrint = z.boolean()

/**
 * Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
 */
export const zQuotaUser = z.string()

/**
 * Legacy upload protocol for media (e.g. "media", "multipart").
 */
export const zUploadType = z.string()

/**
 * Upload protocol for media (e.g. "raw", "multipart").
 */
export const zUploadProtocol = z.string()

export const zSheetsSpreadsheetsCreateData = z.object({
  body: z.optional(zSpreadsheetWritable),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsCreateResponse = zSpreadsheet

export const zSheetsSpreadsheetsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string()),
      includeGridData: z.optional(z.boolean()),
      ranges: z.optional(z.array(z.string()))
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsGetResponse = zSpreadsheet

export const zSheetsSpreadsheetsDeveloperMetadataGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spreadsheetId: z.string(),
    metadataId: z.int()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsDeveloperMetadataGetResponse = zDeveloperMetadata

export const zSheetsSpreadsheetsDeveloperMetadataSearchData = z.object({
  body: z.optional(zSearchDeveloperMetadataRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsDeveloperMetadataSearchResponse = zSearchDeveloperMetadataResponse

export const zSheetsSpreadsheetsSheetsCopyToData = z.object({
  body: z.optional(zCopySheetToAnotherSpreadsheetRequest),
  path: z.object({
    spreadsheetId: z.string(),
    sheetId: z.int()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsSheetsCopyToResponse = zSheetProperties

export const zSheetsSpreadsheetsValuesGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spreadsheetId: z.string(),
    range: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string()),
      dateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
      majorDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
      valueRenderOption: z.optional(z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA']))
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesGetResponse = zValueRange

export const zSheetsSpreadsheetsValuesUpdateData = z.object({
  body: z.optional(zValueRange),
  path: z.object({
    spreadsheetId: z.string(),
    range: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string()),
      includeValuesInResponse: z.optional(z.boolean()),
      responseDateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
      responseValueRenderOption: z.optional(
        z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA'])
      ),
      valueInputOption: z.optional(
        z.enum(['INPUT_VALUE_OPTION_UNSPECIFIED', 'RAW', 'USER_ENTERED'])
      )
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesUpdateResponse = zUpdateValuesResponse

export const zSheetsSpreadsheetsValuesAppendData = z.object({
  body: z.optional(zValueRange),
  path: z.object({
    spreadsheetId: z.string(),
    range: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string()),
      includeValuesInResponse: z.optional(z.boolean()),
      insertDataOption: z.optional(z.enum(['OVERWRITE', 'INSERT_ROWS'])),
      responseDateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
      responseValueRenderOption: z.optional(
        z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA'])
      ),
      valueInputOption: z.optional(
        z.enum(['INPUT_VALUE_OPTION_UNSPECIFIED', 'RAW', 'USER_ENTERED'])
      )
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesAppendResponse = zAppendValuesResponse

export const zSheetsSpreadsheetsValuesClearData = z.object({
  body: z.optional(zClearValuesRequestWritable),
  path: z.object({
    spreadsheetId: z.string(),
    range: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesClearResponse = zClearValuesResponse

export const zSheetsSpreadsheetsValuesBatchClearData = z.object({
  body: z.optional(zBatchClearValuesRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchClearResponse = zBatchClearValuesResponse

export const zSheetsSpreadsheetsValuesBatchClearByDataFilterData = z.object({
  body: z.optional(zBatchClearValuesByDataFilterRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchClearByDataFilterResponse =
  zBatchClearValuesByDataFilterResponse

export const zSheetsSpreadsheetsValuesBatchGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string()),
      dateTimeRenderOption: z.optional(z.enum(['SERIAL_NUMBER', 'FORMATTED_STRING'])),
      majorDimension: z.optional(z.enum(['DIMENSION_UNSPECIFIED', 'ROWS', 'COLUMNS'])),
      ranges: z.optional(z.array(z.string())),
      valueRenderOption: z.optional(z.enum(['FORMATTED_VALUE', 'UNFORMATTED_VALUE', 'FORMULA']))
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchGetResponse = zBatchGetValuesResponse

export const zSheetsSpreadsheetsValuesBatchGetByDataFilterData = z.object({
  body: z.optional(zBatchGetValuesByDataFilterRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchGetByDataFilterResponse =
  zBatchGetValuesByDataFilterResponse

export const zSheetsSpreadsheetsValuesBatchUpdateData = z.object({
  body: z.optional(zBatchUpdateValuesRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchUpdateResponse = zBatchUpdateValuesResponse

export const zSheetsSpreadsheetsValuesBatchUpdateByDataFilterData = z.object({
  body: z.optional(zBatchUpdateValuesByDataFilterRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsValuesBatchUpdateByDataFilterResponse =
  zBatchUpdateValuesByDataFilterResponse

export const zSheetsSpreadsheetsBatchUpdateData = z.object({
  body: z.optional(zBatchUpdateSpreadsheetRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsBatchUpdateResponse = zBatchUpdateSpreadsheetResponse

export const zSheetsSpreadsheetsGetByDataFilterData = z.object({
  body: z.optional(zGetSpreadsheetByDataFilterRequest),
  path: z.object({
    spreadsheetId: z.string()
  }),
  query: z.optional(
    z.object({
      '$.xgafv': z.optional(z.enum(['1', '2'])),
      access_token: z.optional(z.string()),
      alt: z.optional(z.enum(['json', 'media', 'proto'])),
      callback: z.optional(z.string()),
      fields: z.optional(z.string()),
      key: z.optional(z.string()),
      oauth_token: z.optional(z.string()),
      prettyPrint: z.optional(z.boolean()),
      quotaUser: z.optional(z.string()),
      upload_protocol: z.optional(z.string()),
      uploadType: z.optional(z.string())
    })
  )
})

/**
 * Successful response
 */
export const zSheetsSpreadsheetsGetByDataFilterResponse = zSpreadsheet
