// This file is auto-generated by @c4c/generators.
// Do not edit manually.

export interface ClientOptions {
  baseUrl?: string;
  fetch?: typeof fetch;
  headers?: Record<string, string>;
  /**
   * Authentication token for protected procedures
   * Will be automatically added as "Authorization: Bearer <token>" header
   */
  authToken?: string;
  /**
   * Custom function to get auth token dynamically
   */
  getAuthToken?: () => string | undefined | Promise<string | undefined>;
}

interface ResolvedClientOptions {
  baseUrl: string;
  fetch: typeof fetch;
  headers: Record<string, string>;
  authToken?: string;
  getAuthToken?: () => string | undefined | Promise<string | undefined>;
}

function resolveOptions(options: ClientOptions = {}): ResolvedClientOptions {
  const baseUrl = options.baseUrl ?? "http://localhost:3456";
  const fetchImpl = options.fetch ?? (typeof fetch !== "undefined" ? fetch : undefined);
  if (!fetchImpl) {
    throw new Error("fetch is not available in this environment. Provide options.fetch to use the generated client.");
  }
  return {
    baseUrl,
    fetch: fetchImpl,
    headers: {
      "Content-Type": "application/json",
      ...(options.headers ?? {}),
    },
    authToken: options.authToken,
    getAuthToken: options.getAuthToken,
  };
}

export interface ProcedureDefinitions {
  "analytics.stats": {
    input: AnalyticsStatsInput;
    output: AnalyticsStatsOutput;
    requiresAuth: false;
  };
  "analytics.health": {
    input: AnalyticsHealthInput;
    output: AnalyticsHealthOutput;
    requiresAuth: false;
  };
  "products.create": {
    input: ProductsCreateInput;
    output: ProductsCreateOutput;
    requiresAuth: false;
  };
  "products.get": {
    input: ProductsGetInput;
    output: ProductsGetOutput;
    requiresAuth: false;
  };
  "products.list": {
    input: ProductsListInput;
    output: ProductsListOutput;
    requiresAuth: false;
  };
  "products.updateStock": {
    input: ProductsUpdateStockInput;
    output: ProductsUpdateStockOutput;
    requiresAuth: false;
  };
  "users.create": {
    input: UsersCreateInput;
    output: UsersCreateOutput;
    requiresAuth: false;
  };
  "users.delete": {
    input: UsersDeleteInput;
    output: UsersDeleteOutput;
    requiresAuth: false;
  };
  "users.get": {
    input: UsersGetInput;
    output: UsersGetOutput;
    requiresAuth: false;
  };
  "users.list": {
    input: UsersListInput;
    output: UsersListOutput;
    requiresAuth: false;
  };
  "users.update": {
    input: UsersUpdateInput;
    output: UsersUpdateOutput;
    requiresAuth: false;
  };
}

const PROCEDURE_METADATA = {
  "analytics.stats": {
    requiresAuth: false,
  },
  "analytics.health": {
    requiresAuth: false,
  },
  "products.create": {
    requiresAuth: false,
  },
  "products.get": {
    requiresAuth: false,
  },
  "products.list": {
    requiresAuth: false,
  },
  "products.updateStock": {
    requiresAuth: false,
  },
  "users.create": {
    requiresAuth: false,
  },
  "users.delete": {
    requiresAuth: false,
  },
  "users.get": {
    requiresAuth: false,
  },
  "users.list": {
    requiresAuth: false,
  },
  "users.update": {
    requiresAuth: false,
  },
} as const;

export function createClient(options: ClientOptions = {}) {
  const resolved = resolveOptions(options);
  const invoke = async <P extends keyof ProcedureDefinitions>(
    name: P,
    input: ProcedureDefinitions[P]["input"]
  ): Promise<ProcedureDefinitions[P]["output"]> => {
    const metadata = PROCEDURE_METADATA[name as string] ?? { requiresAuth: false };
    const headers = { ...resolved.headers };

    // Add Authorization header for procedures that require auth
    if (metadata.requiresAuth) {
      let token: string | undefined = resolved.authToken;
      if (!token && resolved.getAuthToken) {
        token = await resolved.getAuthToken();
      }
      if (token) {
        const scheme = metadata.authScheme ?? "Bearer";
        headers["Authorization"] = scheme === "Bearer" ? `Bearer ${token}` : token;
      } else {
        console.warn(`Procedure "${String(name)}" requires authentication but no auth token was provided.`);
      }
    }

    const response = await resolved.fetch(`${resolved.baseUrl}/rpc/${String(name)}`, {
      method: "POST",
      headers,
      body: JSON.stringify(input),
    });
    if (!response.ok) {
      const body = await response.text().catch(() => "");
      const message = body ? `${response.status} ${response.statusText}: ${body}` : `${response.status} ${response.statusText}`;
      throw new Error(`RPC request to ${String(name)} failed â€” ${message}`);
    }
    return (await response.json()) as ProcedureDefinitions[P]["output"];
  };
  return {
    analyticsStats: (input: AnalyticsStatsInput) => invoke("analytics.stats", input),
    analyticsHealth: (input: AnalyticsHealthInput) => invoke("analytics.health", input),
    productsCreate: (input: ProductsCreateInput) => invoke("products.create", input),
    productsGet: (input: ProductsGetInput) => invoke("products.get", input),
    productsList: (input: ProductsListInput) => invoke("products.list", input),
    productsUpdateStock: (input: ProductsUpdateStockInput) => invoke("products.updateStock", input),
    usersCreate: (input: UsersCreateInput) => invoke("users.create", input),
    usersDelete: (input: UsersDeleteInput) => invoke("users.delete", input),
    usersGet: (input: UsersGetInput) => invoke("users.get", input),
    usersList: (input: UsersListInput) => invoke("users.list", input),
    usersUpdate: (input: UsersUpdateInput) => invoke("users.update", input),
  } as const;
}

export type Client = ReturnType<typeof createClient>;

export type AnalyticsStatsInput = unknown;
export type AnalyticsStatsOutput = unknown;

export type AnalyticsHealthInput = unknown;
export type AnalyticsHealthOutput = unknown;

export type ProductsCreateInput = unknown;
export type ProductsCreateOutput = unknown;

export type ProductsGetInput = unknown;
export type ProductsGetOutput = unknown;

export type ProductsListInput = unknown;
export type ProductsListOutput = unknown;

export type ProductsUpdateStockInput = unknown;
export type ProductsUpdateStockOutput = unknown;

export type UsersCreateInput = unknown;
export type UsersCreateOutput = unknown;

export type UsersDeleteInput = unknown;
export type UsersDeleteOutput = unknown;

export type UsersGetInput = unknown;
export type UsersGetOutput = unknown;

export type UsersListInput = unknown;
export type UsersListOutput = unknown;

export type UsersUpdateInput = unknown;
export type UsersUpdateOutput = unknown;
