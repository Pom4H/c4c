/**
 * RPC client generator
 *
 * Emits a typed fetch-based client for RPC procedures visible to SDK consumers.
 */

import type { ZodTypeAny } from "zod";
import { isProcedureVisible, type Registry } from "@c4c/core";

export interface RpcClientGeneratorOptions {
	baseUrl?: string;
}

interface GeneratedProcedure {
	name: string;
	pascalName: string;
	inputTypeName: string;
	outputTypeName: string;
	inputType: string;
	outputType: string;
	requiresAuth: boolean;
	requiredRoles?: string[];
	requiredPermissions?: string[];
	authScheme?: string;
}

export function generateRpcClientModule(
	registry: Registry,
	options: RpcClientGeneratorOptions = {}
): string {
	const baseUrl = options.baseUrl ?? "http://localhost:3000";

	const procedures: GeneratedProcedure[] = [];
	for (const [name, procedure] of registry.entries()) {
		if (!isProcedureVisible(procedure.contract, "client")) continue;
		const pascalName = toPascalCase(name);
		const inputTypeName = `${pascalName}Input`;
		const outputTypeName = `${pascalName}Output`;

		const auth = procedure.contract.metadata?.auth as {
			requiresAuth?: boolean;
			requiredRoles?: string[];
			requiredPermissions?: string[];
			authScheme?: string;
		} | undefined;
		const requiresAuth = auth?.requiresAuth ?? false;

		procedures.push({
			name,
			pascalName,
			inputTypeName,
			outputTypeName,
			inputType: toTypeScript(procedure.contract.input),
			outputType: toTypeScript(procedure.contract.output),
			requiresAuth,
			requiredRoles: auth?.requiredRoles,
			requiredPermissions: auth?.requiredPermissions,
			authScheme: auth?.authScheme,
		});
	}

	const lines: string[] = [];
	lines.push("// This file is auto-generated by @c4c/generators.");
	lines.push("// Do not edit manually.\n");

	lines.push("export interface ClientOptions {");
	lines.push('  baseUrl?: string;');
	lines.push('  fetch?: typeof fetch;');
	lines.push('  headers?: Record<string, string>;');
	lines.push('  /**');
	lines.push('   * Authentication token for protected procedures');
	lines.push('   * Will be automatically added as "Authorization: Bearer <token>" header');
	lines.push('   */');
	lines.push('  authToken?: string;');
	lines.push('  /**');
	lines.push('   * Custom function to get auth token dynamically');
	lines.push('   */');
	lines.push('  getAuthToken?: () => string | undefined | Promise<string | undefined>;');
	lines.push("}\n");

	lines.push("interface ResolvedClientOptions {");
	lines.push("  baseUrl: string;");
	lines.push("  fetch: typeof fetch;");
	lines.push("  headers: Record<string, string>;");
	lines.push("  authToken?: string;");
	lines.push("  getAuthToken?: () => string | undefined | Promise<string | undefined>;");
	lines.push("}\n");

	lines.push("function resolveOptions(options: ClientOptions = {}): ResolvedClientOptions {");
	lines.push(`  const baseUrl = options.baseUrl ?? "${baseUrl}";`);
	lines.push("  const fetchImpl = options.fetch ?? (typeof fetch !== \"undefined\" ? fetch : undefined);");
	lines.push('  if (!fetchImpl) {');
	lines.push(
		'    throw new Error("fetch is not available in this environment. Provide options.fetch to use the generated client.");'
	);
	lines.push("  }");
	lines.push("  return {");
	lines.push("    baseUrl,");
	lines.push("    fetch: fetchImpl,");
	lines.push("    headers: {");
	lines.push("      \"Content-Type\": \"application/json\",");
	lines.push("      ...(options.headers ?? {}),");
	lines.push("    },");
	lines.push("    authToken: options.authToken,");
	lines.push("    getAuthToken: options.getAuthToken,");
	lines.push("  };");
	lines.push("}\n");

	lines.push("export interface ProcedureDefinitions {");
	if (procedures.length === 0) {
		lines.push("  // No client-visible procedures were found in the registry.");
	} else {
		for (const procedure of procedures) {
			lines.push(`  "${procedure.name}": {`);
			lines.push(`    input: ${procedure.inputTypeName};`);
			lines.push(`    output: ${procedure.outputTypeName};`);
			lines.push(`    requiresAuth: ${procedure.requiresAuth};`);
			lines.push("  };");
		}
	}
	lines.push("}\n");

	// Add metadata mapping for procedures
	lines.push("const PROCEDURE_METADATA = {");
	if (procedures.length > 0) {
		for (const procedure of procedures) {
			lines.push(`  "${procedure.name}": {`);
			lines.push(`    requiresAuth: ${procedure.requiresAuth},`);
			if (procedure.requiredRoles && procedure.requiredRoles.length > 0) {
				lines.push(`    requiredRoles: ${JSON.stringify(procedure.requiredRoles)},`);
			}
			if (procedure.requiredPermissions && procedure.requiredPermissions.length > 0) {
				lines.push(`    requiredPermissions: ${JSON.stringify(procedure.requiredPermissions)},`);
			}
			if (procedure.authScheme) {
				lines.push(`    authScheme: ${JSON.stringify(procedure.authScheme)},`);
			}
			lines.push("  },");
		}
	}
	lines.push("} as const;\n");

	lines.push("export function createClient(options: ClientOptions = {}) {");
	lines.push("  const resolved = resolveOptions(options);");
	lines.push("  const invoke = async <P extends keyof ProcedureDefinitions>(");
	lines.push("    name: P,");
	lines.push("    input: ProcedureDefinitions[P][\"input\"]");
	lines.push("  ): Promise<ProcedureDefinitions[P][\"output\"]> => {");
	lines.push("    const metadata = PROCEDURE_METADATA[name as string] ?? { requiresAuth: false };");
	lines.push("    const headers = { ...resolved.headers };");
	lines.push("");
	lines.push("    // Add Authorization header for procedures that require auth");
	lines.push("    if (metadata.requiresAuth) {");
	lines.push("      let token: string | undefined = resolved.authToken;");
	lines.push("      if (!token && resolved.getAuthToken) {");
	lines.push("        token = await resolved.getAuthToken();");
	lines.push("      }");
	lines.push("      if (token) {");
	lines.push("        const scheme = metadata.authScheme ?? \"Bearer\";");
	lines.push("        headers[\"Authorization\"] = scheme === \"Bearer\" ? `Bearer ${token}` : token;");
	lines.push("      } else {");
	lines.push("        console.warn(`Procedure \"${String(name)}\" requires authentication but no auth token was provided.`);");
	lines.push("      }");
	lines.push("    }");
	lines.push("");
	lines.push("    const response = await resolved.fetch(`${resolved.baseUrl}/rpc/${String(name)}`, {");
	lines.push("      method: \"POST\",");
	lines.push("      headers,");
	lines.push("      body: JSON.stringify(input),");
	lines.push("    });");
	lines.push("    if (!response.ok) {");
	lines.push(
		"      const body = await response.text().catch(() => \"\");"
	);
	lines.push(
		"      const message = body ? `${response.status} ${response.statusText}: ${body}` : `${response.status} ${response.statusText}`;"
	);
	lines.push("      throw new Error(`RPC request to ${String(name)} failed â€” ${message}`);");
	lines.push("    }");
	lines.push("    return (await response.json()) as ProcedureDefinitions[P][\"output\"];");
	lines.push("  };");
	lines.push("  return {");
	if (procedures.length === 0) {
		lines.push("    // No procedures available.");
	} else {
		for (const procedure of procedures) {
			const camelCaseName = toCamelCase(procedure.name);
			lines.push(
				`    ${camelCaseName}: (input: ${procedure.inputTypeName}) => invoke("${procedure.name}", input),`
			);
		}
	}
	lines.push("  } as const;");
	lines.push("}\n");

	lines.push("export type Client = ReturnType<typeof createClient>;\n");

	for (const procedure of procedures) {
		lines.push(`export type ${procedure.inputTypeName} = ${procedure.inputType};`);
		lines.push(`export type ${procedure.outputTypeName} = ${procedure.outputType};`);
		lines.push("");
	}

	if (procedures.length === 0) {
		lines.push("// Tip: add procedures with metadata.exposure !== \"internal\" to expose them to the client generator.");
	}

	return lines.join("\n").replace(/\n{3,}/g, "\n\n");
}

function toPascalCase(value: string): string {
	return value
		.split(/[^a-zA-Z0-9]+/)
		.filter(Boolean)
		.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
		.join("");
}

function toCamelCase(value: string): string {
	const parts = value.split(/[^a-zA-Z0-9]+/).filter(Boolean);
	if (parts.length === 0) return value;
	return parts[0].toLowerCase() + parts.slice(1).map((segment) => 
		segment.charAt(0).toUpperCase() + segment.slice(1)
	).join("");
}

function toTypeScript(schema: ZodTypeAny, level = 0): string {
	const resolved: any = strip(schema);
	const def = getDef(resolved);
	const typeName = def?.typeName as string | undefined;

	if (typeName === "ZodObject") {
		const shapeSource =
			typeof resolved.shape === "function"
				? resolved.shape()
				: resolved.shape ?? (typeof def.shape === "function" ? def.shape() : def.shape ?? {});
		const shape: Record<string, ZodTypeAny> = shapeSource ?? {};
		const keys = Object.keys(shape).sort();
		const indent = "  ".repeat(level);
		const nextIndent = "  ".repeat(level + 1);

		if (keys.length === 0) {
			return "{}";
		}

		const entries = keys.map((key) => {
			const field = shape[key];
			const { schema: inner, optional, nullable } = unwrapField(field);
			let typeString = toTypeScript(inner, level + 1);
			if (nullable) {
				typeString = `${typeString} | null`;
			}
			const safeKey = safePropertyName(key);
			const optionalToken = optional ? "?" : "";
			return `${nextIndent}${safeKey}${optionalToken}: ${typeString};`;
		});

		return `{\n${entries.join("\n")}\n${indent}}`;
	}

	if (typeName === "ZodArray") {
		const element = def.element ?? resolved.element;
		return `Array<${element ? toTypeScript(element as ZodTypeAny, level + 1) : "unknown"}>`;
	}

	if (typeName === "ZodTuple") {
		const items: ZodTypeAny[] =
			(def.items as ZodTypeAny[]) ?? (Array.isArray(resolved.items) ? resolved.items : []);
		return `[${items.map((item) => toTypeScript(item, level + 1)).join(", ")}]`;
	}

	if (typeName === "ZodUnion") {
		const options: ZodTypeAny[] = Array.isArray(def.options) ? def.options : [];
		return options.map((opt) => toTypeScript(opt, level)).join(" | ");
	}

	if (typeName === "ZodIntersection") {
		const left = def.left as ZodTypeAny | undefined;
		const right = def.right as ZodTypeAny | undefined;
		const leftType = left ? toTypeScript(left, level) : "unknown";
		const rightType = right ? toTypeScript(right, level) : "unknown";
		return `${leftType} & ${rightType}`;
	}

	if (typeName === "ZodRecord") {
		const valueType = def.valueType ? toTypeScript(def.valueType as ZodTypeAny, level) : "unknown";
		return `Record<string, ${valueType}>`;
	}

	if (typeName === "ZodMap") {
		const keyType = def.keyType ? toTypeScript(def.keyType as ZodTypeAny, level) : "string";
		const valueType = def.valueType ? toTypeScript(def.valueType as ZodTypeAny, level) : "unknown";
		return `Record<${keyType}, ${valueType}>`;
	}

	if (typeName === "ZodSet") {
		const valueType = def.valueType ? toTypeScript(def.valueType as ZodTypeAny, level) : "unknown";
		return `Array<${valueType}>`;
	}

	if (typeName === "ZodPromise") {
		const valueType = def.type ? toTypeScript(def.type as ZodTypeAny, level) : "unknown";
		return `Promise<${valueType}>`;
	}

	if (typeName === "ZodLiteral") {
		return JSON.stringify(def.value);
	}

	if (typeName === "ZodNativeEnum") {
		const rawValues = def.values ?? {};
		const values = Array.from(new Set(Object.values(rawValues))).map((value) =>
			JSON.stringify(value)
		);
		return values.join(" | ");
	}

	if (typeName === "ZodEnum") {
		const values: string[] = Array.isArray(def.values)
			? def.values
			: Array.isArray(resolved.options)
				? resolved.options
				: [];
		return values.map((value) => JSON.stringify(value)).join(" | ");
	}

	if (typeName === "ZodDiscriminatedUnion") {
		const options: ZodTypeAny[] = Array.isArray(def.options) ? def.options : [];
		return options.map((opt) => toTypeScript(opt, level)).join(" | ");
	}

	switch (typeName) {
		case "ZodString":
		case "ZodTemplate":
			return "string";
		case "ZodNumber":
		case "ZodInt":
		case "ZodFloat":
		case "ZodNaN":
			return "number";
		case "ZodBigInt":
			return "bigint";
		case "ZodBoolean":
			return "boolean";
		case "ZodDate":
		case "ZodISODate":
		case "ZodISODateTime":
		case "ZodISOTime":
		case "ZodISODuration":
			return "string";
		case "ZodSymbol":
			return "symbol";
		case "ZodUndefined":
			return "undefined";
		case "ZodNull":
			return "null";
		case "ZodAny":
			return "any";
		case "ZodUnknown":
			return "unknown";
		case "ZodNever":
			return "never";
		case "ZodVoid":
			return "void";
		default:
			return "unknown";
	}
}

function strip(schema: ZodTypeAny): ZodTypeAny {
	let current: any = schema;
	while (true) {
		const def = getDef(current);
		const typeName = def?.typeName as string | undefined;

		if (typeName === "ZodLazy" && typeof def.getter === "function") {
			current = def.getter();
			continue;
		}
		if (typeName === "ZodEffects" && def.schema) {
			current = def.schema;
			continue;
		}
		if (typeName === "ZodPipeline" && def.out) {
			current = def.out;
			continue;
		}
		if ((typeName === "ZodDefault" || typeName === "ZodCatch") && def.innerType) {
			current = def.innerType;
			continue;
		}
		if (typeName === "ZodBranded" && def.type) {
			current = def.type;
			continue;
		}
		if (typeName === "ZodReadonly" && def.innerType) {
			current = def.innerType;
			continue;
		}
		return current as ZodTypeAny;
	}
}

function unwrapField(schema: ZodTypeAny) {
	let current: any = schema;
	let optional = false;
	let nullable = false;

	while (true) {
		const def = getDef(current);
		const typeName = def?.typeName as string | undefined;

		if (typeName === "ZodOptional") {
			optional = true;
			current = def.innerType ?? current.unwrap?.();
			continue;
		}
		if (typeName === "ZodNullable") {
			nullable = true;
			current = def.innerType ?? current.unwrap?.();
			continue;
		}
		if (typeName === "ZodDefault") {
			optional = true;
			current = def.innerType;
			continue;
		}
		if (typeName === "ZodCatch") {
			optional = true;
			current = def.innerType;
			continue;
		}
		if (typeName === "ZodEffects") {
			current = def.schema;
			continue;
		}
		if (typeName === "ZodPipeline") {
			current = def.out;
			continue;
		}
		if (typeName === "ZodBranded") {
			current = def.type;
			continue;
		}
		if (typeName === "ZodReadonly") {
			current = def.innerType;
			continue;
		}
		break;
	}

	return {
		schema: strip(current),
		optional,
		nullable,
	};
}

function safePropertyName(key: string): string {
	if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(key)) {
		return key;
	}
	return JSON.stringify(key);
}

function getDef(schema: any): any {
	return schema?._def ?? schema?.def ?? {};
}
